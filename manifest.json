{
  "source_base_path": "/home/joe/src/NetTopologySuite/doc",
  "xrefmap": "xrefmap.yml",
  "files": [
    {
      "type": "Resource",
      "output": {
        "resource": {
          "relative_path": "index.json"
        }
      }
    },
    {
      "type": "Resource",
      "source_relative_path": "images/minClearance.png",
      "output": {
        "resource": {
          "relative_path": "images/minClearance.png"
        }
      },
      "version": ""
    },
    {
      "type": "Conceptual",
      "source_relative_path": "index.md",
      "output": {
        ".html": {
          "relative_path": "index.html"
        }
      },
      "version": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.AngleUtility.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.AngleUtility.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.AngleUtility",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.AngleUtility.yml\" sourcestartlinenumber=\"1\">Utility functions for working with angles.\nUnless otherwise noted, methods in this class express angles in radians.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Area.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Area.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Area",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Area.yml\" sourcestartlinenumber=\"1\">Functions for computing area.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.BoundaryNodeRules.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.BoundaryNodeRules.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.BoundaryNodeRules",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.BoundaryNodeRules.yml\" sourcestartlinenumber=\"1\">Provides access to static instances of common <xref href=\"NetTopologySuite.Algorithm.IBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.CGAlgorithms3D.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.CGAlgorithms3D.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.CGAlgorithms3D",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.CGAlgorithms3D.yml\" sourcestartlinenumber=\"1\">Basic computational geometry algorithms\nfor geometry and coordinates defined in 3-dimensional Cartesian space.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.CGAlgorithmsDD.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.CGAlgorithmsDD.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.CGAlgorithmsDD",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.CGAlgorithmsDD.yml\" sourcestartlinenumber=\"1\">Implements basic computational geometry algorithms using <xref href=\"NetTopologySuite.Mathematics.DD\" data-throw-if-not-resolved=\"false\"></xref> arithmetic.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Centroid.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Centroid.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Centroid",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Centroid.yml\" sourcestartlinenumber=\"1\">Computes the centroid of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> of any dimension.\nFor collections the centroid is computed for the collection of\nnon-empty elements of highest dimension.\nThe centroid of an empty geometry is <code>null</code></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Construct.LargestEmptyCircle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.yml\" sourcestartlinenumber=\"1\">Constructs the Largest Empty Circle for a set\nof obstacle geometries, up to a given accuracy distance tolerance.\nThe obstacles may be any combination of point, linear and polygonal geometries.</p>\n<p></p>\nThe Largest Empty Circle (LEC) is the largest circle\nwhose interior does not intersect with any obstacle\nand whose center lies within a polygonal boundary.\nThe circle center is the point in the interior of the boundary\nwhich has the farthest distance from the obstacles\n(up to the accuracy of the distance tolerance).\nThe circle itself is determined by the center point\nand a point lying on an obstacle determining the circle radius.\n<p></p>\nThe polygonal boundary may be supplied explicitly.\nIf it is not specified the convex hull of the obstacles is used as the boundary.\n<p></p>\nTo compute an LEC which lies <i>wholly</i> within\na polygonal boundary, include the boundary of the polygon(s) as a linear obstacle.\n<p></p>\nThe implementation uses a successive-approximation technique\nover a grid of square cells covering the obstacles and boundary.\nThe grid is refined using a branch-and-bound algorithm.\nPoint containment and distance are computed in a performant\nway by using spatial indexes.\n<p></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.yml\" sourcestartlinenumber=\"1\">Constructs the Maximum Inscribed Circle for a\npolygonal <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>, up to a specified tolerance.\nThe Maximum Inscribed Circle is determined by a point in the interior of the area\nwhich has the farthest distance from the area boundary,\nalong with a boundary point at that distance.</p>\n<p></p>\nIn the context of geography the center of the Maximum Inscribed Circle\nis known as the <b>Pole of Inaccessibility</b>.\nA cartographic use case is to determine a suitable point\nto place a map label within a polygon.\n<p></p>\nThe radius length of the Maximum Inscribed Circle is a\nmeasure of how \"narrow\" a polygon is. It is the\ndistance at which the negative buffer becomes empty.\n<p></p>\nThe class supports polygons with holes and multipolygons.\n<p></p>\nThe implementation uses a successive-approximation technique\nover a grid of square cells covering the area geometry.\nThe grid is refined using a branch-and-bound algorithm.\nPoint containment and distance are computed in a performant\nway by using spatial indexes.\n<h3>Future Enhancements</h3>\n<ul><li>Support a polygonal constraint on placement of center</li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Construct.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Construct.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Construct",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.Construct.md\" sourcestartlinenumber=\"5\">Provides classes that implement various kinds of geometric constructions.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.ConvexHull.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.ConvexHull.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.ConvexHull",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.ConvexHull.yml\" sourcestartlinenumber=\"1\">Computes the convex hull of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nThe convex hull is the smallest convex Geometry that contains all the\npoints in the input Geometry.</p>\n<p></p>\nUses the Graham Scan algorithm.\n<p></p>\nIncorporates heuristics to optimize checking for degenerate results,\nand to reduce the number of points processed for large inputs.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance.yml\" sourcestartlinenumber=\"1\">The Fréchet distance is a measure of similarity between curves. Thus, it can\nbe used like the Hausdorff distance.</p>\n<p></p>\nAn analogy for the Fréchet distance taken from\n<a href=\"http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf\">\nComputing Discrete Fréchet Distance</a>:\n<pre>\nA man is walking a dog on a leash: the man can move\non one curve, the dog on the other; both may vary their\nspeed, but backtracking is not allowed.\n</pre>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter.yml\" sourcestartlinenumber=\"1\">A coordinate filter that computes the maximum <xref href=\"NetTopologySuite.Algorithm.Distance.PointPairDistance\" data-throw-if-not-resolved=\"false\"></xref> between points of\nan assigned <code>Geometry</code> and all filtered geometries. The filtered geometries' line segments\nare</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.MaxPointDistanceFilter.yml\" sourcestartlinenumber=\"1\">A coordinate filter that computes the maximum <xref href=\"NetTopologySuite.Algorithm.Distance.PointPairDistance\" data-throw-if-not-resolved=\"false\"></xref> between points of\nan assigned <code>Geometry</code> and all filtered geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance.yml\" sourcestartlinenumber=\"1\">An algorithm for computing a distance metric\nwhich is an approximation to the Hausdorff Distance\nbased on a discretization of the input <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.DistanceToPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.DistanceToPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance.DistanceToPoint",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Distance.DistanceToPoint.yml\" sourcestartlinenumber=\"1\">Computes the Euclidean distance (L2 metric) from a <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.PointPairDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.PointPairDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance.PointPairDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Distance.PointPairDistance.yml\" sourcestartlinenumber=\"1\">Contains a pair of points and the distance between them.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Distance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Distance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Distance",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.Distance.md\" sourcestartlinenumber=\"5\">Classes to compute distance metrics between geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.DistanceComputer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.DistanceComputer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.DistanceComputer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.DistanceComputer.yml\" sourcestartlinenumber=\"1\">Functions to compute distance between basic geometric structures.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.ElevationModel.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.ElevationModel.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.ElevationModel",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.ElevationModel.yml\" sourcestartlinenumber=\"1\">A base elevation model class.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.ElevationModels.CoordinateSequenceToXYAndZ.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.ElevationModels.CoordinateSequenceToXYAndZ.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.ElevationModels.CoordinateSequenceToXYAndZ",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.ElevationModels.CoordinateSequenceToXYAndZ.yml\" sourcestartlinenumber=\"1\">Method signature to extract xy- and z-ordinate values from a coordinate sequence</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.ElevationModels.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.ElevationModels.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.ElevationModels",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.ElevationModels.yml\" sourcestartlinenumber=\"1\">Extension methods to work with <xref href=\"NetTopologySuite.Algorithm.ElevationModel\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.HCoordinate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.HCoordinate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.HCoordinate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.HCoordinate.yml\" sourcestartlinenumber=\"1\">Represents a homogeneous coordinate in a 2-D coordinate space.\nIn NTS <xref href=\"NetTopologySuite.Algorithm.HCoordinate\" data-throw-if-not-resolved=\"false\"></xref>s are used as a clean way\nof computing intersections between line segments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Hull.ConcaveHull.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Hull.ConcaveHull.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Hull.ConcaveHull",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Hull.ConcaveHull.yml\" sourcestartlinenumber=\"1\">Constructs a concave hull of a set of points.\nA concave hull is a possibly non-convex polygon containing all the input points.\nA given set of points has a sequence of hulls of increasing concaveness,\ndetermined by a numeric target parameter.</p>\n<p></p>\nThe hull is constructed by removing border triangles\nof the Delaunay Triangulation of the points,\nas long as their \"size\" is larger than the target criterion.\n<p></p>\nThe target criteria are:\n<table><tbody><tr><td class=\"term\">Maximum Edge Length</td><td class=\"description\">the length of the longest edge of the hull is no larger\nthan this value.</td></tr><tr><td class=\"term\">Maximum Edge Length Factor</td><td class=\"description\">determines the Maximum Edge Length\nby a fraction of the difference between the longest and shortest edge lengths\nin the Delaunay Triangulation.\nThis normalizes the <b>Maximum Edge Length</b> to be scale-free.\nA value of 1 produces the convex hull; a value of 0 produces maximum concaveness.\n</td></tr><tr><td class=\"term\">Alpha</td><td class=\"description\">produces Alpha-shapes,\nby removing border triangles with a circumradius greater than alpha.\nLarge values produce the convex hull; a value of 0 produces maximum concaveness.</td></tr></tbody></table>\nThe preferred criterion is the <b>Maximum Edge Length Ratio</b>, since it is\nscale-free and local(so that no assumption needs to be made about the\ntotal amount of concaveness present).\n<p></p>\nOther length criteria can be used by setting the Maximum Edge Length directly.\nFor example, use a length relative to the longest edge length\nin the Minimum Spanning Tree of the point set.\nOr, use a length derived from the <xref href=\"NetTopologySuite.Algorithm.Hull.ConcaveHull.UniformGridEdgeLength(NetTopologySuite.Geometries.Geometry)\" data-throw-if-not-resolved=\"false\"></xref> value.\n<p></p>\nThe computed hull is always a single connected <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref>\n(unless it is degenerate, in which case it will be a <xref href=\"NetTopologySuite.Geometries.Point\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>).\nThis constraint may cause the concave hull to fail to meet the target criteria.\n<p></p>\nOptionally the concave hull can be allowed to contain holes by setting <xref href=\"NetTopologySuite.Algorithm.Hull.ConcaveHull.HolesAllowed\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.yml\" sourcestartlinenumber=\"1\">Constructs a concave hull of a set of polygons, respecting\nthe polygons as constraints.\nA concave hull is a possibly non-convex polygon containing all the input polygons.\nA given set of polygons has a sequence of hulls of increasing concaveness,\ndetermined by a numeric target parameter.\nThe computed hull &quot;fills the gap&quot; between the polygons,\nand does not intersect their interior.</p>\n<p></p>\nThe concave hull is constructed by removing the longest outer edges\nof the Delaunay Triangulation of the space between the polygons,\nuntil the target criterion parameter is reached.\n<p></p>\nThe target criteria are:\n<ul><li><span class=\"term\">Maximum Edge Length</span>the length of the longest edge between the polygons is no larger\nthan this value.</li><li><span class=\"term\">Maximum Edge Length Ratio</span>determine the Maximum Edge Length\nas a fraction of the difference between the longest and shortest edge lengths\nbetween the polygons.\nThis normalizes the <b>Maximum Edge Length</b> to be scale-free.\nA value of 1 produces the convex hull; a value of 0 produces the original polygons.</li></ul>\nThe preferred criterion is the <b>Maximum Edge Length Ratio</b>, since it is\nscale-free and local (so that no assumption needs to be made about the\ntotal amount of concaveness present).\n<p></p>\nOptionally the concave hull can be allowed to contain holes, via\n<xref href=\"NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons.HolesAllowed\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nThe hull can be specified as being \"tight\", which means it follows the outer boundaries\nof the input polygons.\n<p></p>\nThe input polygons must form a valid MultiPolygon\n(i.e.they must be non - overlapping).\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Hull.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Hull.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Hull",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.Hull.md\" sourcestartlinenumber=\"5\">Contains classes implementing algorithms to compute hulls\nof geometry objects.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.Hull.md\" sourcestartlinenumber=\"8\">See also <xref href=\"NetTopologySuite.Algorithm.ConvexHull\">ConvexHull</xref></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.IBoundaryNodeRule.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.IBoundaryNodeRule.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.IBoundaryNodeRule",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.IBoundaryNodeRule.yml\" sourcestartlinenumber=\"1\">An interface for rules which determine whether node points\nwhich are in boundaries of <xref href=\"NetTopologySuite.Geometries.ILineal\" data-throw-if-not-resolved=\"false\"></xref> geometry components\nare in the boundary of the parent geometry collection.\nThe SFS specifies a single kind of boundary node rule,\nthe <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref> rule.\nHowever, other kinds of Boundary Node Rules are appropriate\nin specific situations (for instance, linear network topology\nusually follows the <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.EndPointBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref>.)\nSome JTS operations\n(such as <xref href=\"NetTopologySuite.Operation.Relate.RelateOp\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NetTopologySuite.Operation.BoundaryOp\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NetTopologySuite.Operation.Valid.IsSimpleOp\" data-throw-if-not-resolved=\"false\"></xref>)\nallow the BoundaryNodeRule to be specified,\nand respect the supplied rule when computing the results of the operation.</p>\n<p></p>\nAn example use case for a non-SFS-standard Boundary Node Rule is\nthat of checking that a set of <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s have\nvalid linear network topology, when turn-arounds are represented\nas closed rings.  In this situation, the entry road to the\nturn-around is only valid when it touches the turn-around ring\nat the single (common) endpoint.  This is equivalent\nto requiring the set of <tt>LineString</tt>s to be\n<b>simple</b> under the <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.EndPointBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref>.\nThe SFS-standard <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref> is not\nsufficient to perform this test, since it\nstates that closed rings have <b>no</b> boundary points.\n<p></p>\nThis interface and its subclasses follow the <tt>Strategy</tt> design pattern.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.IPointInAreaLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.IPointInAreaLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.IPointInAreaLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.IPointInAreaLocator.yml\" sourcestartlinenumber=\"1\">An interface for classes which determine the <xref href=\"NetTopologySuite.Geometries.Location\" data-throw-if-not-resolved=\"false\"></xref> of points in a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.InteriorPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.InteriorPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.InteriorPoint",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.InteriorPoint.yml\" sourcestartlinenumber=\"1\">Computes an interior point of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nAn interior point is guaranteed to lie in the interior of the Geometry,\nif it possible to calculate such a point exactly.\nFor collections the interior point is computed for the collection of\nnon-empty elements of highest dimension.\nOtherwise, the point may lie on the boundary of the geometry.</p>\n<p></p>\nThe interior point of an empty geometry is <code>POINT EMPTY</code>.\n<h2>Algorithm</h2>\nThe point is chosen to be \"close to the center\" of the geometry.\nThe location depends on the dimension of the input:\n<ul><li><span class=\"term\">Dimension 2</span>the interior point is constructed in the middle of the longest interior segment\nof a line bisecting the area.</li><li><span class=\"term\">Dimension 1</span>the interior point is the interior or boundary vertex closest to the centroid.</li><li><span class=\"term\">Dimension 0</span>the point is the point closest to the centroid.</li></ul>\n<xref href=\"NetTopologySuite.Algorithm.Centroid\" data-throw-if-not-resolved=\"false\"></xref>\n<xref href=\"NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle\" data-throw-if-not-resolved=\"false\"></xref>\n<xref href=\"NetTopologySuite.Algorithm.Construct.LargestEmptyCircle\" data-throw-if-not-resolved=\"false\"></xref>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.InteriorPointArea.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.InteriorPointArea.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.InteriorPointArea",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.InteriorPointArea.yml\" sourcestartlinenumber=\"1\">Computes a point in the interior of an areal geometry.\nThe point will lie in the geometry interior\nin all except certain pathological cases.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.InteriorPointLine.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.InteriorPointLine.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.InteriorPointLine",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.InteriorPointLine.yml\" sourcestartlinenumber=\"1\">Computes a point in the interior of an linear point.\nAlgorithm:\nFind an interior vertex which is closest to\nthe centroid of the linestring.\nIf there is no interior vertex, find the endpoint which is\nclosest to the centroid.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.InteriorPointPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.InteriorPointPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.InteriorPointPoint",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.InteriorPointPoint.yml\" sourcestartlinenumber=\"1\">Computes a point in the interior of an point point.\nAlgorithm:\nFind a point which is closest to the centroid of the point.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.IntersectionComputer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.IntersectionComputer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.IntersectionComputer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.IntersectionComputer.yml\" sourcestartlinenumber=\"1\">Functions to compute intersection points between lines and line segments.</p>\n<p></p>\nIn general it is not possible to compute\nthe intersection point of two lines exactly, due to numerical roundoff.\nThis is particularly true when the lines are nearly parallel.\nThese routines uses numerical conditioning on the input values\nto ensure that the computed value is very close to the correct value.\n<p></p>\nThe Z-ordinate is ignored, and not populated.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Length.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Length.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Length",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Length.yml\" sourcestartlinenumber=\"1\">Functions for computing length.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.LineIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.LineIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.LineIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.LineIntersector.yml\" sourcestartlinenumber=\"1\">A <code>LineIntersector</code> is an algorithm that can both test whether\ntwo line segments intersect and compute the intersection point(s)\nif they do.</p>\n<p>\nThere are three possible outcomes when determining whether two line segments intersect:\n<ul><li><xref href=\"NetTopologySuite.Algorithm.LineIntersector.NoIntersection\" data-throw-if-not-resolved=\"false\"></xref> - the segments do not intersect</li><li><xref href=\"NetTopologySuite.Algorithm.LineIntersector.PointIntersection\" data-throw-if-not-resolved=\"false\"></xref> - the segments intersect in a single point</li><li><xref href=\"NetTopologySuite.Algorithm.LineIntersector.CollinearIntersection\" data-throw-if-not-resolved=\"false\"></xref> - the segments are collinear and they intersect in a line segment</li></ul>\n\n<p>\nFor segments which intersect in a single point, the point may be either an endpoint\nor in the interior of each segment.\nIf the point lies in the interior of both segments,\nthis is termed a <i>proper intersection</i>.\nThe property <xref href=\"NetTopologySuite.Algorithm.LineIntersector.IsProper\" data-throw-if-not-resolved=\"false\"></xref> test for this situation.\n</p><p>\nThe intersection point(s) may be computed in a precise or non-precise manner.\nComputing an intersection point precisely involves rounding it\nvia a supplied <xref href=\"NetTopologySuite.Algorithm.LineIntersector.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.\n</p><p>\nLineIntersectors do not perform an initial envelope intersection test\nto determine if the segments are disjoint.\nThis is because this class is likely to be used in a context where\nenvelope overlap is already known to occur (or be likely).\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator.yml\" sourcestartlinenumber=\"1\">An interface for classes which determine the <xref href=\"NetTopologySuite.Geometries.Location\" data-throw-if-not-resolved=\"false\"></xref> of\npoints in areal geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator.yml\" sourcestartlinenumber=\"1\">Determines the <xref href=\"NetTopologySuite.Geometries.Location\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s relative to\nan areal geometry, using indexing for efficiency.\nThis algorithm is suitable for use in cases where\nmany points will be tested against a given area.</p>\n<p></p>\nThe <code>Location</code> is computed precisely, th that points\nlocated on the geometry boundary or segments will\nreturn <xref href=\"NetTopologySuite.Geometries.Location.Boundary\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\n<xref href=\"NetTopologySuite.Geometries.IPolygonal\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NetTopologySuite.Geometries.LinearRing\" data-throw-if-not-resolved=\"false\"></xref> geometries are supported.\n<p></p>\nThe index is lazy-loaded, which allows\ncreating instances even if they are not used.\n<p></p>\nThread-safe and immutable.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions.yml\" sourcestartlinenumber=\"1\">Static methods for <xref href=\"NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator\" data-throw-if-not-resolved=\"false\"></xref> classes</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator.yml\" sourcestartlinenumber=\"1\">Computes the location of points\nrelative to an areal <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>,\nusing a simple <code>O(n)</code> algorithm.</p>\n<p>\nThe algorithm used reports\nif a point lies in the interior, exterior,\nor exactly on the boundary of the Geometry.\n</p>\n<p>\nInstance methods are provided to implement\nthe interface <xref href=\"NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator\" data-throw-if-not-resolved=\"false\"></xref>.\nHowever, they provide no performance\nadvantage over the class methods.\n</p>\n<p>\nThis algorithm is suitable for use in cases where\nonly a few points will be tested.\nIf many points will be tested,\n<xref href=\"NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator\" data-throw-if-not-resolved=\"false\"></xref> may provide better performance.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Locate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Locate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Locate",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.Locate.md\" sourcestartlinenumber=\"5\">Classes to determine the topological location of points in geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure.yml\" sourcestartlinenumber=\"1\">Measures the degree of similarity between two <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s\nusing the area of intersection between the geometries.\nThe measure is normalized to lie in the range [0, 1].\nHigher measures indicate a great degree of similarity.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure.yml\" sourcestartlinenumber=\"1\">Measures the degree of similarity between two\n<xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s using the Fréchet distance metric.\nThe measure is normalized to lie in the range [0, 1].\nHigher measures indicate a great degree of similarity.</p>\n<p></p>\nThe measure is computed by computing the Fréchet distance\nbetween the input geometries, and then normalizing\nthis by dividing it by the diagonal distance across\nthe envelope of the combined geometries.\n<p></p>\nNote: the input should be normalized, especially when\nmeasuring <xref href=\"NetTopologySuite.Geometries.MultiPoint\" data-throw-if-not-resolved=\"false\"></xref> geometries because for the\nFréchet distance the order of {@link Coordinate}s is\nimportant.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure.yml\" sourcestartlinenumber=\"1\">Measures the degree of similarity between two <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s using the Hausdorff distance metric.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Match.ISimilarityMeasure.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Match.ISimilarityMeasure.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Match.ISimilarityMeasure",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Match.ISimilarityMeasure.yml\" sourcestartlinenumber=\"1\">An interface for classes which measures the degree of similarity between two {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Algorithm.Match.ISimilarityMeasure.yml\" sourcestartlinenumber=\"1\"></xref> Geometry}s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner.yml\" sourcestartlinenumber=\"1\">Provides methods to mathematically combine <xref href=\"NetTopologySuite.Algorithm.Match.ISimilarityMeasure\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Match.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Match.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Match",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.Match.md\" sourcestartlinenumber=\"5\">Classes to compute matching metrics between geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.MinimumAreaRectangle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.MinimumAreaRectangle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.MinimumAreaRectangle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.MinimumAreaRectangle.yml\" sourcestartlinenumber=\"1\">Computes the minimum-area rectangle enclosing a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nUnlike the <xref href=\"NetTopologySuite.Geometries.Envelope\" data-throw-if-not-resolved=\"false\"></xref>, the rectangle may not be axis-parallel.</p>\n<p></p>\nThe first step in the algorithm is computing the convex hull of the Geometry.\nIf the input Geometry is known to be convex, a hint can be supplied to\navoid this computation.\n<p></p>\nIn degenerate cases the minimum enclosing geometry\nmay be a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"NetTopologySuite.Geometries.Point\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nThe minimum - area enclosing rectangle does not necessarily\nhave the minimum possible width.\nUse {@link MinimumDiameter} to compute this.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.MinimumBoundingCircle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.MinimumBoundingCircle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.MinimumBoundingCircle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.MinimumBoundingCircle.yml\" sourcestartlinenumber=\"1\">Computes the <b>Minimum Bounding Circle</b> (MBC) for the points in a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nThe MBC is the smallest circle which <tt>cover</tt>s all the input points\n(this is also sometimes known as the <b>Smallest Enclosing Circle</b>).\nThis is equivalent to computing the Maximum Diameter of the input point set.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.MinimumDiameter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.MinimumDiameter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.MinimumDiameter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.MinimumDiameter.yml\" sourcestartlinenumber=\"1\">Computes the minimum diameter of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.NotRepresentableException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.NotRepresentableException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.NotRepresentableException",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.Orientation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.Orientation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.Orientation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.Orientation.yml\" sourcestartlinenumber=\"1\">Functions to compute the orientation of basic geometric structures\nincluding point triplets(triangles) and rings.\nOrientation is a fundamental property of planar geometries\n(and more generally geometry on two-dimensional manifolds).</p>\n<p></p>\nDetermining triangle orientation\nis notoriously subject to numerical precision errors\nin the case of collinear or nearly collinear points.\nNTS uses extended-precision arithmetic to increase\nthe robustness of the computation.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.OrientationIndex.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.OrientationIndex.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.OrientationIndex",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.OrientationIndex.yml\" sourcestartlinenumber=\"1\">Angle orientation</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.PointLocation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.PointLocation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.PointLocation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.PointLocation.yml\" sourcestartlinenumber=\"1\">Functions for locating points within basic geometric\nstructures such as lines and rings.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.PointLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.PointLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.PointLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.PointLocator.yml\" sourcestartlinenumber=\"1\">Computes the topological relationship (<xref href=\"NetTopologySuite.Geometries.Location\" data-throw-if-not-resolved=\"false\"></xref>) of a single point to a Geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.RayCrossingCounter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.RayCrossingCounter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.RayCrossingCounter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RayCrossingCounter.yml\" sourcestartlinenumber=\"1\">Counts the number of segments crossed by a horizontal ray extending to the right\nfrom a given point, in an incremental fashion.</p>\n<p>This can be used to determine whether a point lies in a <xref href=\"NetTopologySuite.Geometries.IPolygonal\" data-throw-if-not-resolved=\"false\"></xref> geometry.</p>\n<p>The class determines the situation where the point lies exactly on a segment.</p>\n<p>When being used for Point-In-Polygon determination, this case allows short-circuiting the evaluation.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.RectangleLineIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.RectangleLineIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.RectangleLineIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RectangleLineIntersector.yml\" sourcestartlinenumber=\"1\">Computes whether a rectangle intersects line segments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.RobustDeterminant.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.RobustDeterminant",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"1\">Implements an algorithm to compute the\nsign of a 2x2 determinant for double precision values robustly.\nIt is a direct translation of code developed by Olivier Devillers.</p>\n<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"5\">The original code carries the following copyright notice:</p>\n<hr sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"6\">\n<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"7\">Author : Olivier Devillers\nOlivier.Devillers<xref href=\"sophia.inria.fr\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@sophia.inria.fr\" sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"8\"></xref>\nhttp:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html</p>\n<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"11\">Olivier Devillers has allowed the code to be distributed under\nthe LGPL (2012-02-16) saying &quot;It is ok for LGPL distribution.&quot;</p>\n<hr sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"14\">\n<hr sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"15\">\n<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"16\">Copyright (c) 1995  by  INRIA Prisme Project\nBP 93 06902 Sophia Antipolis Cedex, France.\nAll rights reserved</p>\n<hr sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustDeterminant.yml\" sourcestartlinenumber=\"19\">\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.RobustLineIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.RobustLineIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm.RobustLineIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Algorithm.RobustLineIntersector.yml\" sourcestartlinenumber=\"1\">A robust version of <xref href=\"NetTopologySuite.Algorithm.LineIntersector\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Algorithm.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Algorithm.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Algorithm",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"5\">Contains classes and interfaces implementing fundamental computational geometry algorithms.</p>\n<h2 id=\"robustness\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"7\">Robustness</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"8\">Geometrical algorithms involve a combination of combinatorial and numerical computation. As with all numerical computation using finite-precision numbers, the algorithms chosen are susceptible to problems of robustness. A robustness problem occurs when a numerical calculation produces an incorrect answer for some inputs due to round-off errors. Robustness problems are especially serious in geometric computation, since they can result in errors during topology building.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"10\">There are many approaches to dealing with the problem of robustness in geometrical computation. Not surprisingly, most robust algorithms are substantially more complex and less performant than the non-robust versions. Fortunately, NTS is sensitive to robustness problems in only a few key functions (such as line intersection and the point-in-polygon test). There are efficient robust algorithms available for these functions, and these algorithms are implemented in NTS.</p>\n<h2 id=\"computational-performance\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"12\">Computational Performance</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"13\">Runtime performance is an important consideration for a production-quality implementation of geometric algorithms. The most computationally intensive algorithm used in NTS is intersection detection. NTS methods need to determine both all intersection between the line segments in a single Geometry (self-intersection) and all intersections between the line segments of two different Geometries.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"15\">The obvious naive algorithm for intersection detection (comparing every segment with every other) has unacceptably slow performance. There is a large literature of faster algorithms for intersection detection. Unfortunately, many of them involve substantial code complexity. NTS tries to balance code simplicity with performance gains. It uses some simple techniques to produce substantial performance gains for common types of input data.</p>\n<h1 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"17\">Package Specification</h1>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"18\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"18\">Java Topology Suite Technical Specifications</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"19\"><a href=\"http://www.opengis.org/techno/specs.htm\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Algorithm.md\" sourcestartlinenumber=\"19\">OpenGIS Simple Features Specification for SQL</a></li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Coverage.CoverageGapFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Coverage.CoverageGapFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Coverage.CoverageGapFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Coverage.CoverageGapFinder.yml\" sourcestartlinenumber=\"1\">Finds gaps in a polygonal coverage.\nGaps are holes in the coverage which are narrower than a given width.</p>\n<p></p>\nThe coverage should be valid according to {@link CoverageValidator}.\nIf this is not the case, some gaps may not be reported, or the invocation may fail.\n<p></p>\nThis is a more accurate way of identifying gaps\nthan using {@link CoverageValidator#setGapWidth(double)}.\nGaps which separate the coverage into two disjoint regions are not detected.\nGores are not identified as gaps.&gt;\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Coverage.CoveragePolygonValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Coverage.CoveragePolygonValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Coverage.CoveragePolygonValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Coverage.CoveragePolygonValidator.yml\" sourcestartlinenumber=\"1\">Validates that a polygon forms a valid polygonal coverage\nwith the set of polygons adjacent to it.\nIf the polygon is coverage-valid an empty { <xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Coverage.CoveragePolygonValidator.yml\" sourcestartlinenumber=\"3\"></xref> LineString} is returned.\nOtherwise, the result is a linear geometry containing\nthe polygon boundary linework causing the invalidity.</p>\n<p></p>\nA polygon is coverage-valid if:\n<ol><li>The polygon interior does not intersect the interior of other polygons.</li><li>If the polygon boundary intersects another polygon boundary, the vertices\nand line segments of the intersection match exactly.</li></ol>\n<p></p>\nThe algorithm detects the following coverage errors:\n<ol><li>the polygon is a duplicate of another one</li><li>a polygon boundary segment equals an adjacent segment (with same orientation).\nThis determines that the polygons overlap</li><li>a polygon boundary segment is collinear and overlaps an adjacent segment\nbut is not equal to it\n</li><li>a polygon boundary segment touches an adjacent segment at a non-vertex point</li><li>a polygon boundary segment crosses into an adjacent polygon</li><li>a polygon boundary segment is in the interior of an adjacent polygon</li></ol>\n<p></p>\n<p sourcefile=\"obj/api/NetTopologySuite.Coverage.CoveragePolygonValidator.yml\" sourcestartlinenumber=\"18\">If any of these errors is present, the target polygon\ndoes not form a valid coverage with the adjacent polygons.</p>\n<p></p>\nThe validity rules do not preclude properly noded gaps between coverage polygons.\nHowever, this class can detect narrow gaps,\nby specifying a maximum gap width using {@link #setGapWidth(double)}.\nNote that this will also identify narrow gaps separating disjoint coverage regions,\nand narrow gores.\nIn some situations it may also produce false positives\n(i.e.linework identified as part of a gap which is wider than the given width).\nTo fully identify gaps it maybe necessary to use <xref href=\"NetTopologySuite.Coverage.CoverageUnion\" data-throw-if-not-resolved=\"false\"></xref> and analyze\nthe holes in the result to see if they are acceptable.\n<p></p>\nA polygon may be coverage-valid with respect to\na set of surrounding polygons, but the collection as a whole may not\nform a clean coverage.For example, the target polygon boundary may be fully matched\nby adjacent boundary segments, but the adjacent set contains polygons\nwhich are not coverage - valid relative to other ones in the set.\nA coverage is valid only if every polygon in the coverage is coverage - valid.\nUse <xref href=\"NetTopologySuite.Coverage.CoverageValidator\" data-throw-if-not-resolved=\"false\"></xref> to validate an entire set of polygons.\n<p></p>\nThe adjacent set may contain polygons which do not intersect the target polygon.\nThese are effectively ignored during validation (but may decrease performance).\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Coverage.CoverageSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Coverage.CoverageSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Coverage.CoverageSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Coverage.CoverageSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies the boundaries of the polygons in a polygonal coverage\nwhile preserving the original coverage topology.\nAn area-based simplification algorithm\n(similar to Visvalingam-Whyatt simplification)\nis used to provide high-quality results.\nAlso supports simplifying just the inner edges in a coverage,\nwhich allows simplifying &quot;patches&quot; without affecting their boundary.</p>\n<p></p>\nThe amount of simplification is determined by a tolerance value,\nwhich is a non-negative quantity. It equates roughly to the maximum\ndistance by which a simplified line can change from the original.\n(In fact, it is the square root of the area tolerance used\nin the Visvalingam-Whyatt algorithm.)\n<p></p>\nThe simplified result coverage has the following characteristics:\n<ul><li>It has the same number of polygonal geometries as the input</li><li>If the input is a valid coverage, then so is the result</li><li>Node points (inner vertices shared by three or more polygons,\nor boundary vertices shared by two or more) are not changed</li><li>Polygons maintain their line-adjacency (edges are never removed)</li><li>Rings are simplified to a minimum of 4 vertices, to better preserve their shape</li><li>Rings smaller than the area tolerance are removed where possible.\nThis applies to both holes and \"islands\" (multipolygon elements\nwhich are disjoint or touch another polygon at a single vertex).\nAt least one polygon is retained for each input geometry\n(the one with largest area).</li></ul>\n<p></p>\nThis class supports simplification using different distance tolerances\nfor inner and outer edges of the coverage(including no simplfication\nusing a tolerance of 0.0).\nThis allows, for example, inner simplification, which simplifies\nonly edges of the coverage which are adjacent to two polygons.\nThis allows partial simplification of a coverage, since a simplified\nsubset of a coverage still matches the remainder of the coverage.\n<p></p>\nThe class allows specifying a separate tolerance for each element of the input coverage.\n<p></p>\nThe input coverage should be valid according to <xref href=\"NetTopologySuite.Coverage.CoverageValidator\" data-throw-if-not-resolved=\"false\"></xref>.\nInvalid coverages may still be simplified, but the result will likely still be invalid.\n<p></p>\n<b>NOTE:</b><br>Due to different implementations of the <code>PriorityQueue</code> classes used in JTS and NTS\nthe results of the <code>CoverageSimplifier</code>'s simplification methods are not guaranteed\nto be the same. Nonetheless both results are valid.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Coverage.CoverageUnion.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Coverage.CoverageUnion.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Coverage.CoverageUnion",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Coverage.CoverageUnion.yml\" sourcestartlinenumber=\"1\">Unions a polygonal coverage in an efficient way.</p>\n<p></p>\nValid polygonal coverage topology allows merging polygons in a very efficient way.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Coverage.CoverageValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Coverage.CoverageValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Coverage.CoverageValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Coverage.CoverageValidator.yml\" sourcestartlinenumber=\"1\">Validates a polygonal coverage, and returns the locations of\ninvalid polygon boundary segments if found.</p>\n<p></p>\nA polygonal coverage is a set of polygons which may be edge-adjacent but do\nnot overlap.\nCoverage algorithms(such as { @link CoverageUnion}\nor simplification)\ngenerally require the input coverage to be valid to produce correct results.\nA polygonal coverage is valid if:\n<ol><li>The interiors of all polygons do not intersect(are disjoint).\nThis is the case if no polygon has a boundary which intersects the interior of another polygon,\nand no two polygons are identical.</li><li>If the boundaries of polygons intersect, the vertices\nand line segments of the intersection match exactly.</li></ol>\n<p></p>\nA valid coverage may contain holes(regions of no coverage).\nSometimes it is desired to detect whether coverages contain\nnarrow gaps between polygons\n(which can be a result of digitizing error or misaligned data).\nThis class can detect narrow gaps,\nby specifying a maximum gap width using {@link #setGapWidth(double)}.\nNote that this also identifies narrow gaps separating disjoint coverage regions,\nand narrow gores.\nIn some situations it may also produce false positives\n(linework identified as part of a gap which is actually wider).\nSee <xref href=\"NetTopologySuite.Coverage.CoverageGapFinder\" data-throw-if-not-resolved=\"false\"></xref> for an alternate way to detect gaps which may be more accurate.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Coverage.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Coverage.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Coverage",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"5\">Contains classes that operate on polygonal coverages.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"7\">A polygonal coverage is a set of polygonal geometries which is non-overlapping and edge-matched\n(<xref href=\"NetTopologySuite.Geometries.Polygon\">Polygon</xref> or <xref href=\"NetTopologySuite.Geometries.MultiPolygon\">MultiPolygon</xref>)\nA set of polygonal geometries is a valid coverage if:</p>\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"11\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"11\">Each geometry is valid.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"12\">The interiors of all polygons are disjoint (they are not overlapping).\nThis is the case if no polygon has a boundary which intersects the interior of another polygon.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"14\">Where polygons are adjacent (i.e. their boundaries intersect),\nthey are <b>edge matched</b>: the vertices\n(and thus line segments) of the common boundary match exactly.</li>\n</ol>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"18\">A coverage may contain holes and disjoint regions.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"20\">Coverage algorithms (such as <xref href=\"NetTopologySuite.Coverage.CoverageUnion\">CoverageUnion</xref>)\ngenerally require the input coverage to be valid to produce correct results.\nCoverages can be validated using {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Coverage.md\" sourcestartlinenumber=\"22\"></xref> CoverageValidator}.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.DataStructures.Interval.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.DataStructures.Interval.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.DataStructures.Interval",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.DataStructures.Interval.yml\" sourcestartlinenumber=\"1\">Structure for a closed 1-dimensional ℝ-interval</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.DataStructures.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.DataStructures.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.DataStructures",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Densify.Densifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Densify.Densifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Densify.Densifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Densify.Densifier.yml\" sourcestartlinenumber=\"1\">Densifies a geometry by inserting extra vertices along the line segments\ncontained in the geometry.\nAll segments in the created densified geometry will be <b>no longer</b>\nthan the given distance tolerance\n(that is, all segments in the output will have length less than or equal to\nthe distance tolerance).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Densify.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Densify.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Densify",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Densify.md\" sourcestartlinenumber=\"5\">Classes to perform densification on geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Dissolve.DissolveEdgeGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Dissolve.DissolveEdgeGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Dissolve.DissolveEdgeGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Dissolve.DissolveEdgeGraph.yml\" sourcestartlinenumber=\"1\">A graph containing <xref href=\"NetTopologySuite.Dissolve.DissolveHalfEdge\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Dissolve.DissolveHalfEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Dissolve.DissolveHalfEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Dissolve.DissolveHalfEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Dissolve.DissolveHalfEdge.yml\" sourcestartlinenumber=\"1\">A HalfEdge which carries information\nrequired to support <xref href=\"NetTopologySuite.Dissolve.LineDissolver\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Dissolve.LineDissolver.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Dissolve.LineDissolver.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Dissolve.LineDissolver",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Dissolve.LineDissolver.yml\" sourcestartlinenumber=\"1\">Dissolves the linear components\nfrom a collection of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s.\ninto a set of maximal-length <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s\nin which every unique segment appears once only.\nThe output linestrings run between node vertices\nof the input, which are vertices which have\neither degree 1, or degree 3 or greater.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Dissolve.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Dissolve.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Dissolve",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.EdgeGraph.EdgeGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.EdgeGraph.EdgeGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.EdgeGraph.EdgeGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.EdgeGraph.EdgeGraph.yml\" sourcestartlinenumber=\"1\">A graph comprised of <xref href=\"NetTopologySuite.EdgeGraph.HalfEdge\" data-throw-if-not-resolved=\"false\"></xref>s.\nIt supports tracking the vertices in the graph\nvia edges incident on them,\nto allow efficient lookup of edges and vertices.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.EdgeGraph.EdgeGraphBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.EdgeGraph.EdgeGraphBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.EdgeGraph.EdgeGraphBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.EdgeGraph.EdgeGraphBuilder.yml\" sourcestartlinenumber=\"1\">Builds an edge graph from geometries containing edges.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.EdgeGraph.HalfEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.EdgeGraph.HalfEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.EdgeGraph.HalfEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.EdgeGraph.HalfEdge.yml\" sourcestartlinenumber=\"1\">Represents a directed component of an edge in an <xref href=\"NetTopologySuite.EdgeGraph.EdgeGraph\" data-throw-if-not-resolved=\"false\"></xref>.\nHalfEdges link vertices whose locations are defined by <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s.\nHalfEdges start at an <b>origin</b> vertex,\nand terminate at a <b>destination</b> vertex.\nHalfEdges always occur in symmetric pairs, with the <xref href=\"NetTopologySuite.EdgeGraph.HalfEdge.Sym\" data-throw-if-not-resolved=\"false\"></xref> method\ngiving access to the oppositely-oriented component.\nHalfEdges and the methods on them form an edge algebra,\nwhich can be used to traverse and query the topology\nof the graph formed by the edges.</p>\n<p></p>\nTo support graphs where the edges are sequences of coordinates\neach edge may also have a direction point supplied.\nThis is used to determine the ordering\nof the edges around the origin.\nHalfEdges with the same origin are ordered\nso that the ring of edges formed by them is oriented CCW.\n<p></p>\nBy design HalfEdges carry minimal information\nabout the actual usage of the graph they represent.\nThey can be subclassed to carry more information if required.\n<p></p>\nHalfEdges form a complete and consistent data structure by themselves,\nbut an <xref href=\"NetTopologySuite.EdgeGraph.EdgeGraph\" data-throw-if-not-resolved=\"false\"></xref> is useful to allow retrieving edges\nby vertex and edge location, as well as ensuring\nedges are created and linked appropriately.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.EdgeGraph.MarkHalfEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.EdgeGraph.MarkHalfEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.EdgeGraph.MarkHalfEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.EdgeGraph.MarkHalfEdge.yml\" sourcestartlinenumber=\"1\">A <xref href=\"NetTopologySuite.EdgeGraph.HalfEdge\" data-throw-if-not-resolved=\"false\"></xref> which supports\nmarking edges with a boolean flag.\nUseful for algorithms which perform graph traversals.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.EdgeGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.EdgeGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.EdgeGraph",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Coordinate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Coordinate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Coordinate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Coordinate.yml\" sourcestartlinenumber=\"1\">A lightweight class used to store coordinates on the 2-dimensional Cartesian plane.</p>\n<p>\nThe base data object is suitable for use with coordinate sequences with\n<code>dimension</code> = 2 and <code>measures</code> = 0.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateArrays.BidirectionalComparator.yml\" sourcestartlinenumber=\"1\">A comparator for <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref> arrays modulo their directionality.\nE.g. if two coordinate arrays are identical but reversed\nthey will compare as equal under this ordering.\nIf the arrays are not equal, the ordering returned\nis the ordering in the forward direction.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateArrays.ForwardComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateArrays.ForwardComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateArrays.ForwardComparator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateArrays.ForwardComparator.yml\" sourcestartlinenumber=\"1\">Compares two <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref> arrays\nin the forward direction of their coordinates,\nusing lexicographic ordering.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateArrays.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateArrays.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateArrays",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateArrays.yml\" sourcestartlinenumber=\"1\">Useful utility functions for handling Coordinate arrays.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateEqualityComparer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateEqualityComparer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateEqualityComparer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateEqualityComparer.yml\" sourcestartlinenumber=\"1\">A class that can be used to test coordinates for equality.</p>\n<p></p>\nIt uses the algorithm that was default for NTS prior to v2.2,\ni.e. checks if the 2d distance between coordinates <code>x</code>\nand <code>y</code> is less than or equal to a tolerance value.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateFilter.yml\" sourcestartlinenumber=\"1\">An implementation of <xref href=\"NetTopologySuite.Geometries.ICoordinateFilter\" data-throw-if-not-resolved=\"false\"></xref> that delegates the\nfilter action to a provided method.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateList.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateList.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateList",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateList.yml\" sourcestartlinenumber=\"1\">A list of Coordinates, which may\nbe set to prevent repeated coordinates from occurring in the list.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateM.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateM.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateM",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateM.yml\" sourcestartlinenumber=\"1\">A lightweight class used to store coordinates on the 2-dimensional Cartesian plane\nand an additional measure (<xref href=\"NetTopologySuite.Geometries.CoordinateM.M\" data-throw-if-not-resolved=\"false\"></xref>) value.</p>\n<p>\nThis data object is suitable for use with coordinate sequences with\n<code>dimension</code> = 3 and <code>measures</code> = 1.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateSequence",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateSequenceComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateSequenceComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateSequenceComparator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateSequenceComparator.yml\" sourcestartlinenumber=\"1\">Compares two <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateSequenceEx.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateSequenceEx.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateSequenceEx",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateSequenceFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateSequenceFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateSequenceFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateSequenceFactory.yml\" sourcestartlinenumber=\"1\">An object that knows how to build a particular implementation of\n<code>CoordinateSequence</code> from an array of Coordinates.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateSequences.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateSequences.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateSequences",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateSequences.yml\" sourcestartlinenumber=\"1\">Utility functions for manipulating <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateZ.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateZ.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateZ",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateZ.yml\" sourcestartlinenumber=\"1\">A lightweight class used to store coordinates on the 2-dimensional Cartesian plane\nand an additional z-ordinate (<xref href=\"NetTopologySuite.Geometries.CoordinateZ.Z\" data-throw-if-not-resolved=\"false\"></xref>) value.</p>\n<p>\nThis base data object is suitable for use with coordinate sequences with\n<code>dimension</code> = 3 and <code>measures</code> = 0.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.CoordinateZM.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.CoordinateZM.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.CoordinateZM",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.CoordinateZM.yml\" sourcestartlinenumber=\"1\">A lightweight class used to store coordinates on the 2-dimensional Cartesian plane\nand additional z- and m-ordinate values (<xref href=\"NetTopologySuite.Geometries.CoordinateZ.Z\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NetTopologySuite.Geometries.CoordinateZM.M\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>\nThis data object is suitable for use with coordinate sequences with\n<code>dimension</code> = 4 and <code>measures</code> = 1.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Coordinates.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Coordinates.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Coordinates",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Coordinates.yml\" sourcestartlinenumber=\"1\">Useful utility functions for handling Coordinate objects.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Dimension.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Dimension.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Dimension",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Dimension.yml\" sourcestartlinenumber=\"1\">Provides constants representing the dimensions of a point, a curve and a surface.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.DimensionUtility.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.DimensionUtility.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.DimensionUtility",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.DimensionUtility.yml\" sourcestartlinenumber=\"1\">Class containing static methods for conversions\nbetween dimension values and characters.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Envelope.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Envelope.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Envelope",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Envelope.yml\" sourcestartlinenumber=\"1\">Defines a rectangular region of the 2D coordinate plane.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.FilterMethod.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.FilterMethod.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.FilterMethod",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.FilterMethod.yml\" sourcestartlinenumber=\"1\">Delegate function declaration to handle filter operation</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Geometry.SortIndexValue.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Geometry.SortIndexValue.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Geometry.SortIndexValue",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Geometry.SortIndexValue.yml\" sourcestartlinenumber=\"1\">An enumeration of sort values for geometries</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Geometry.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Geometry.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Geometry",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Geometry.yml\" sourcestartlinenumber=\"1\">A representation of a planar, linear vector geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryCollection.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryCollection.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryCollection",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryCollection.yml\" sourcestartlinenumber=\"1\">Basic implementation of <code>GeometryCollection</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryCollectionEnumerator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryCollectionEnumerator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryCollectionEnumerator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryCollectionEnumerator.yml\" sourcestartlinenumber=\"1\">Iterates over all <code>Geometry</code>'s in a <code>GeometryCollection</code>.\nImplements a pre-order depth-first traversal of the <code>GeometryCollection</code>\n(which may be nested). The original <code>GeometryCollection</code> is\nreturned as well (as the first object), as are all sub-collections. It is\nsimple to ignore the <code>GeometryCollection</code> objects if they are not\nneeded.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryComponentFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryComponentFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryComponentFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryComponentFilter.yml\" sourcestartlinenumber=\"1\">An <xref href=\"NetTopologySuite.Geometries.IGeometryComponentFilter\" data-throw-if-not-resolved=\"false\"></xref> implementation that applies filtering with the provided <xref href=\"NetTopologySuite.Geometries.FilterMethod\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryFactory.yml\" sourcestartlinenumber=\"1\">Supplies a set of utility methods for building Geometry objects\nfrom lists of Coordinates.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryFactoryEx.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryFactoryEx.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryFactoryEx",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryFactoryEx.yml\" sourcestartlinenumber=\"1\">An extended <xref href=\"NetTopologySuite.Geometries.GeometryFactory\" data-throw-if-not-resolved=\"false\"></xref> that is capable of enforcing a ring orientation for polygons.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryOverlay.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryOverlay.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryOverlay",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryOverlay.yml\" sourcestartlinenumber=\"1\">A class that encapsulates geometry overlay functionality</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.GeometryRelate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.GeometryRelate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.GeometryRelate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.GeometryRelate.yml\" sourcestartlinenumber=\"1\">Class which provides the available Relate operations for <xref href=\"NetTopologySuite.NtsGeometryServices\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IBoundable-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IBoundable-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IBoundable<T, TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IBoundable-2.yml\" sourcestartlinenumber=\"1\">A spatial object in an AbstractSTRtree.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.ICoordinateFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.ICoordinateFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.ICoordinateFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.ICoordinateFilter.yml\" sourcestartlinenumber=\"1\">An interface for classes which use the values of the coordinates in a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nCoordinate filters can be used to implement centroid and\nenvelope computation, and many other functions.<p></p>\n<p></p>\n<code>ICoordinateFilter</code> is\nan example of the Gang-of-Four Visitor pattern. \n<p></p>\n<b>Note</b>: it is not recommended to use these filters to mutate the coordinates.\nThere is no guarantee that the coordinate is the actual object stored in the source geometry.\nIn particular, modified values may not be preserved if the source Geometry uses a non-default <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>.\nIf in-place mutation is required, use <xref href=\"NetTopologySuite.Geometries.ICoordinateSequenceFilter\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.ICoordinateSequenceFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.ICoordinateSequenceFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.ICoordinateSequenceFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.ICoordinateSequenceFilter.yml\" sourcestartlinenumber=\"1\">An interface for classes which process the coordinates in a <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>.\nA filter can either record information about each coordinate,\nor change the value of the coordinate.\nFilters can be\nused to implement operations such as coordinate transformations, centroid and\nenvelope computation, and many other functions.\n<xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> classes support the concept of applying a\n<code>CoordinateSequenceFilter</code> to each\n<xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>s they contain.</p>\n<p></p>\nFor maximum efficiency, the execution of filters can be short-circuited by using the <xref href=\"NetTopologySuite.Geometries.ICoordinateSequenceFilter.Done\" data-throw-if-not-resolved=\"false\"></xref> property.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter.yml\" sourcestartlinenumber=\"1\">A variant of <xref href=\"NetTopologySuite.Geometries.ICoordinateSequenceFilter\" data-throw-if-not-resolved=\"false\"></xref>, except it receives each\n<xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref> just once, instead of once for each of its coordinates.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IExpandable-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IExpandable-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IExpandable<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IExpandable-1.yml\" sourcestartlinenumber=\"1\">Interface describing objects that can expand themselves by objects of type <code class=\"typeparamref\">T</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IGeometryComponentFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IGeometryComponentFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IGeometryComponentFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IGeometryComponentFilter.yml\" sourcestartlinenumber=\"1\"><code>Geometry</code> classes support the concept of applying\nan <code>IGeometryComponentFilter</code> filter to a geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IGeometryFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IGeometryFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IGeometryFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IGeometryFilter.yml\" sourcestartlinenumber=\"1\"><code>GeometryCollection</code> classes support the concept of\napplying a <code>IGeometryFilter</code> to the <code>Geometry</code>.\nThe filter is applied to every element <code>Geometry</code>.\nA <code>IGeometryFilter</code> can either record information about the <code>Geometry</code>\nor change the <code>Geometry</code> in some way.\n<code>IGeometryFilter</code> is an example of the Gang-of-Four Visitor pattern.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IIntersectable-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IIntersectable-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IIntersectable<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IIntersectable-1.yml\" sourcestartlinenumber=\"1\">Interface describing objects that can perform an intersects predicate with <code class=\"typeparamref\">T</code> objects.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.ILineal.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.ILineal.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.ILineal",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.ILineal.yml\" sourcestartlinenumber=\"1\">Interface to identify all <code>Geometry</code> subclasses that have a <code>Dimension</code> of <xref href=\"NetTopologySuite.Geometries.Dimension.Curve\" data-throw-if-not-resolved=\"false\"></xref>\nand have components which are <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IPolygonal.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IPolygonal.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IPolygonal",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IPolygonal.yml\" sourcestartlinenumber=\"1\">Interface to identify all <code>Geometry</code> subclasses that have a <code>Dimension</code> of <xref href=\"NetTopologySuite.Geometries.Dimension.Surface\" data-throw-if-not-resolved=\"false\"></xref>\nand have components that are <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IPuntal.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IPuntal.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IPuntal",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IPuntal.yml\" sourcestartlinenumber=\"1\">Interface to identify all <code>Geometry</code> subclasses that have a <code>Dimension</code> of <xref href=\"NetTopologySuite.Geometries.Dimension.Point\" data-throw-if-not-resolved=\"false\"></xref>\nand have components that ar <xref href=\"NetTopologySuite.Geometries.Point\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.CoordinateArraySequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.yml\" sourcestartlinenumber=\"1\">A <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref> backed by an array of <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s.\nThis is the implementation that <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s use by default.</p>\n<p></p>\nCoordinates returned by <xref href=\"NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.ToCoordinateArray\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinate(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NetTopologySuite.Geometries.Implementation.CoordinateArraySequence.GetCoordinate(System.Int32%2cNetTopologySuite.Geometries.Coordinate)\" data-throw-if-not-resolved=\"false\"></xref> are live --\nmodifications to them are actually changing the\nCoordinateSequence's underlying data.\nA dimension may be specified for the coordinates in the sequence,\nwhich may be 2 or 3.\nThe actual coordinates will always have 3 ordinates,\nbut the dimension is useful as metadata in some situations.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory.yml\" sourcestartlinenumber=\"1\">Creates CoordinateSequences represented as an array of Coordinates.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence.yml\" sourcestartlinenumber=\"1\">A coordinate sequence that follows the dotspatial shape range</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory.yml\" sourcestartlinenumber=\"1\">A coordinate sequence factory class that creates DotSpatial's Shape/ShapeRange like coordinate sequences.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence.yml\" sourcestartlinenumber=\"1\">A <code>CoordinateSequence</code> implementation based on a packed arrays.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.PackedType.yml\" sourcestartlinenumber=\"1\">An enumeration of valid type codes</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory.yml\" sourcestartlinenumber=\"1\">Builds packed array coordinate sequences.\nThe array data type can be either\n<code>double</code> or <code>float</code>,\nand defaults to <code>double</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence.yml\" sourcestartlinenumber=\"1\">Packed coordinate sequence implementation based on doubles.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence.yml\" sourcestartlinenumber=\"1\">Packed coordinate sequence implementation based on floats.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.RawCoordinateSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.RawCoordinateSequence.yml\" sourcestartlinenumber=\"1\">An implementation of <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref> that packs its contents in a way that\ncan be customized by the creator.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory.yml\" sourcestartlinenumber=\"1\">Factory for creating <xref href=\"NetTopologySuite.Geometries.Implementation.RawCoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref> instances.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Implementation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Implementation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Implementation",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.IntersectionMatrix.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.IntersectionMatrix.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.IntersectionMatrix",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.IntersectionMatrix.yml\" sourcestartlinenumber=\"1\">Models a <b>Dimensionally Extended Nine-Intersection Model (DE-9IM)</b> matrix.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.LineSegment.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.LineSegment.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.LineSegment",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.LineSegment.yml\" sourcestartlinenumber=\"1\">Represents a line segment defined by two <code>Coordinate</code>s.\nProvides methods to compute various geometric properties\nand relationships of line segments.\nThis class is designed to be easily mutable (to the extent of\nhaving its contained points public).\nThis supports a common pattern of reusing a single LineSegment\nobject as a way of computing segment properties on the\nsegments defined by arrays or lists of <code>Coordinate</code>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.LineString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.LineString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.LineString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.LineString.yml\" sourcestartlinenumber=\"1\">Models an OGC-style <code>LineString</code></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.LinearRing.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.LinearRing.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.LinearRing",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.LinearRing.yml\" sourcestartlinenumber=\"1\">Models an OGC SFS <code>LinearRing</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.LinearRingOrientation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.LinearRingOrientation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.LinearRingOrientation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.LinearRingOrientation.yml\" sourcestartlinenumber=\"1\">An enumeration of ring orientation values</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Location.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Location.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Location",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Location.yml\" sourcestartlinenumber=\"1\">The location of a <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref> relative to a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.LocationUtility.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.LocationUtility.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.LocationUtility",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.LocationUtility.yml\" sourcestartlinenumber=\"1\">Utility class for <xref href=\"NetTopologySuite.Geometries.Location\" data-throw-if-not-resolved=\"false\"></xref> enumeration</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.MultiLineString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.MultiLineString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.MultiLineString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.MultiLineString.yml\" sourcestartlinenumber=\"1\">Models a collection of <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n<p></p>\nAny collection of <code>LineString</code>s is a valid <code>MultiLineString</code>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.MultiPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.MultiPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.MultiPoint",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.MultiPoint.yml\" sourcestartlinenumber=\"1\">Models a collection of <code>Point</code>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.MultiPolygon.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.MultiPolygon.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.MultiPolygon",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.MultiPolygon.yml\" sourcestartlinenumber=\"1\">Basic implementation of <code>MultiPolygon</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.OctagonalEnvelope.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.OctagonalEnvelope.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.OctagonalEnvelope",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.OctagonalEnvelope.yml\" sourcestartlinenumber=\"1\">A bounding container for a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> which is in the shape of a general octagon.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.OgcCompliantGeometryFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.OgcCompliantGeometryFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.OgcCompliantGeometryFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.OgcCompliantGeometryFactory.yml\" sourcestartlinenumber=\"1\">OGC compliant geometry factory</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.OgcGeometryType.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.OgcGeometryType.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.OgcGeometryType",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.OgcGeometryType.yml\" sourcestartlinenumber=\"1\">Enumeration of OGC Geometry Types</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Ordinate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Ordinate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Ordinate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Ordinate.yml\" sourcestartlinenumber=\"1\">Identifies the different well-supported components of coordinate values.</p>\n<p>\nAll supported coordinates define values for at least the X and the Y components.\n</p>\n<p>\nThe first 16 spatial and 16 measure dimensions may also be accessed this way.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Ordinates.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Ordinates.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Ordinates",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Ordinates.yml\" sourcestartlinenumber=\"1\">Flags for Ordinate values</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.OrdinatesUtility.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.OrdinatesUtility.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.OrdinatesUtility",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.OrdinatesUtility.yml\" sourcestartlinenumber=\"1\">Static utility functions for dealing with <xref href=\"NetTopologySuite.Geometries.Ordinates\" data-throw-if-not-resolved=\"false\"></xref> and dimension</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.PerOrdinateEqualityComparer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.PerOrdinateEqualityComparer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.PerOrdinateEqualityComparer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.PerOrdinateEqualityComparer.yml\" sourcestartlinenumber=\"1\">A class that can be used to test coordinates for equality.</p>\n<p></p>\nThis class test for each ordinate if the distance is less\nthan a tolerance value.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Point.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Point.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Point",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Point.yml\" sourcestartlinenumber=\"1\">Represents a single point.</p>\n<p></p>\nA <code>Point</code> is topologically valid if and only if:\n<ul><li>The coordinate which defines it if any) is a valid coordinate\n(i.e. does not have an <code>NaN</code> X- or Y-ordinate</li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Polygon.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Polygon.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Polygon",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Polygon.yml\" sourcestartlinenumber=\"1\">Represents a polygon with linear edges, which may include holes.\nThe outer boundary (shell)\nand inner boundaries (holes) of the polygon are represented by {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Geometries.Polygon.yml\" sourcestartlinenumber=\"3\"></xref> LinearRing}s.\nThe boundary rings of the polygon may have any orientation.\nPolygons are closed, simple geometries by definition.</p>\n<p></p>\nThe polygon model conforms to the assertions specified in the\n<a href=\"http://www.opengis.org/techno/specs.htm\">OpenGIS Simple Features\nSpecification for SQL</a>.\n<p></p>\nA <code>Polygon</code> is topologically valid if and only if:\n<ul><li>the coordinates which define it are valid coordinates</li><li>the linear rings for the shell and holes are valid\n(i.e. are closed and do not self-intersect)</li><li>holes touch the shell or another hole at at most one point\n(which implies that the rings of the shell and holes must not cross)</li><li>the interior of the polygon is connected,\nor equivalently no sequence of touching holes\nmakes the interior of the polygon disconnected\n(i.e. effectively split the polygon into two pieces).</li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Position.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Position.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Position",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Position.yml\" sourcestartlinenumber=\"1\">Indicates the position of a location relative to a\nnode or edge component of a planar topological structure.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.PrecisionModel.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.PrecisionModel.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.PrecisionModel",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.PrecisionModel.yml\" sourcestartlinenumber=\"1\">Specifies the precision model of the <code>Coordinate</code>s in a <code>Geometry</code>.\nIn other words, specifies the grid of allowable points for a <code>Geometry</code>.\nA precision model may be<b>floating</b> (<xref href=\"NetTopologySuite.Geometries.PrecisionModels.Floating\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.PrecisionModels.FloatingSingle\" data-throw-if-not-resolved=\"false\"></xref>),\nin which case normal floating-point value semantics apply.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.PrecisionModels.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.PrecisionModels.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.PrecisionModels",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry.yml\" sourcestartlinenumber=\"1\">A base class for <xref href=\"NetTopologySuite.Geometries.Prepared.IPreparedGeometry\" data-throw-if-not-resolved=\"false\"></xref> subclasses.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.IPreparedGeometry.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.IPreparedGeometry.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared.IPreparedGeometry",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Prepared.IPreparedGeometry.yml\" sourcestartlinenumber=\"1\">An interface for classes which prepare <xref href=\"NetTopologySuite.Geometries.Prepared.IPreparedGeometry.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s\nin order to optimize the performance of repeated calls to specific geometric operations.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory.yml\" sourcestartlinenumber=\"1\">A factory for creating <xref href=\"NetTopologySuite.Geometries.Prepared.IPreparedGeometry\" data-throw-if-not-resolved=\"false\"></xref>s. It chooses an appropriate implementation of PreparedGeometry\nbased on the geometric type of the input geometry.</p>\n<p></p>\nIn the future, the factory may accept hints that indicate\nspecial optimizations which can be performed.\n<p></p>\nInstances of this class are thread-safe.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.PreparedLineString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.PreparedLineString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared.PreparedLineString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Prepared.PreparedLineString.yml\" sourcestartlinenumber=\"1\">A prepared version for <xref href=\"NetTopologySuite.Geometries.ILineal\" data-throw-if-not-resolved=\"false\"></xref> geometries.</p>\n<p>Instances of this class are thread-safe</p>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.PreparedPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.PreparedPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared.PreparedPoint",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Prepared.PreparedPoint.yml\" sourcestartlinenumber=\"1\">A prepared version for <xref href=\"NetTopologySuite.Geometries.IPuntal\" data-throw-if-not-resolved=\"false\"></xref> geometries.</p>\n<p>Instances of this class are thread-safe.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.PreparedPolygon.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.PreparedPolygon.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared.PreparedPolygon",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Prepared.PreparedPolygon.yml\" sourcestartlinenumber=\"1\">A prepared version for <xref href=\"NetTopologySuite.Geometries.IPolygonal\" data-throw-if-not-resolved=\"false\"></xref> geometries.\nThis class supports both <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref>s and <xref href=\"NetTopologySuite.Geometries.MultiPolygon\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n<p>This class does <b>not</b> support MultiPolygons which are non-valid\n(e.g. with overlapping elements).\n</p>\n<p></p>\nInstances of this class are thread-safe and immutable.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Prepared.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Prepared.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Prepared",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Quadrant.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Quadrant.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Quadrant",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Quadrant.yml\" sourcestartlinenumber=\"1\">Quadrant values</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.TopologyException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.TopologyException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.TopologyException",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.TopologyException.yml\" sourcestartlinenumber=\"1\">Indicates an invalid or inconsistent topological situation encountered during processing</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Triangle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Triangle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Triangle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Triangle.yml\" sourcestartlinenumber=\"1\">Represents a planar triangle, and provides methods for calculating various\nproperties of triangles.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.AffineTransformation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.AffineTransformation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.AffineTransformation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.AffineTransformation.yml\" sourcestartlinenumber=\"1\">Represents an affine transformation on the 2D Cartesian plane.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder.yml\" sourcestartlinenumber=\"1\">Builds an <xref href=\"NetTopologySuite.Geometries.Utilities.AffineTransformation\" data-throw-if-not-resolved=\"false\"></xref> defined by a set of control vectors.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.AffineTransformationFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.AffineTransformationFactory.yml\" sourcestartlinenumber=\"1\">Supports creating <xref href=\"NetTopologySuite.Geometries.Utilities.AffineTransformation\" data-throw-if-not-resolved=\"false\"></xref>s defined by various kinds of inputs and transformation mapping rules.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter.yml\" sourcestartlinenumber=\"1\">Extracts a representative <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>\nfrom each connected component of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.EnvelopeCombiner",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.EnvelopeCombiner.yml\" sourcestartlinenumber=\"1\">Utility to combine just the <xref href=\"NetTopologySuite.Geometries.Envelope\" data-throw-if-not-resolved=\"false\"></xref>s of a list of geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.Extracter-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.Extracter-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.Extracter<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.Extracter-1.yml\" sourcestartlinenumber=\"1\">Class to extract single instance geometries of T</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.Extracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.Extracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.Extracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.Extracter.yml\" sourcestartlinenumber=\"1\">This class offers utility methods to extract single component\ngeometries of requested type from ordinary geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper.yml\" sourcestartlinenumber=\"1\">Maps the members of a <xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref>\ninto another <tt>GeometryCollection</tt> via a defined\nmapping function.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryCombiner.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryCombiner.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryCombiner",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryCombiner.yml\" sourcestartlinenumber=\"1\">Combines <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s to produce a <xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref> of the most appropriate type.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateOperation.yml\" sourcestartlinenumber=\"1\">A GeometryEditorOperation which edits the coordinate list of a <code>Geometry</code>.\nOperates on Geometry subclasses which contains a single coordinate list.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.CoordinateSequenceOperation.yml\" sourcestartlinenumber=\"1\">A <xref href=\"NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation\" data-throw-if-not-resolved=\"false\"></xref> which edits the <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>\nof a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nOperates on Geometry subclasses which contains a single coordinate list.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.IGeometryEditorOperation.yml\" sourcestartlinenumber=\"1\">A interface which specifies an edit operation for Geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.NoOpGeometryOperation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryEditor.NoOpGeometryOperation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryEditor.NoOpGeometryOperation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.NoOpGeometryOperation.yml\" sourcestartlinenumber=\"1\">A GeometryEditorOperation which does not modify\nthe input geometry.\nThis can be used for simple changes of\n<xref href=\"NetTopologySuite.Geometries.GeometryFactory\" data-throw-if-not-resolved=\"false\"></xref> (including PrecisionModel and SRID).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryEditor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryEditor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryEditor.yml\" sourcestartlinenumber=\"1\">A class which supports creating new <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s\nwhich are modifications of existing ones,\nmaintaining the same type structure.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryExtracter-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryExtracter-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryExtracter<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryExtracter-1.yml\" sourcestartlinenumber=\"1\">Extracts the components of type <code>T</code> from a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryExtracter.yml\" sourcestartlinenumber=\"1\">Extracts the components of a given type from a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName.yml\" sourcestartlinenumber=\"1\">Extracts the components of type <code>T</code> from a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryFixer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryFixer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryFixer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryFixer.yml\" sourcestartlinenumber=\"1\">Fixes a geometry to be a valid geometry, while preserving as much as\npossible of the shape and location of the input.\nValidity is determined according to <xref href=\"NetTopologySuite.Geometries.Geometry.IsValid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nInput geometries are always processed, so even valid inputs may\nhave some minor alterations.The output is always a new geometry object.\n<h2>Semantic Rules</h2>\n<ol><li>Vertices with non-finite X or Y ordinates are removed (as per <xref href=\"NetTopologySuite.Geometries.Coordinate.IsValid\" data-throw-if-not-resolved=\"false\"></xref>)</li><li>Repeated points are reduced to a single point</li><li>Empty atomic geometries are valid and are returned unchanged</li><li>Empty elements are removed from collections</li><li><code>Point</code>: keep valid coordinate, or EMPTY</li><li><code>LineString</code>: coordinates are fixed</li><li><code>LinearRing</code>: coordinates are feixed, keep valid ring or else convert into <code>LineString</code></li><li><code>Polygon</code>: transform into a valid polygon or multipolygon, \npreserving as much of the extent and vertices as possible.\n<ul><li>Rings are fixed to ensure they are valid</li><li>Holes intersection the shell are subtracted from the shell</li><li>Holes outside the shell are converted into polygons</li></ul></li><li><code>MultiPolygon</code>: each polygon is fixed, \nthen result made non - overlapping (via union)</li><li><code>GeometryCollection</code>: each element is fixed</li><li>Collapsed lines and polygons are handled as follows,\ndepending on the <code>keepCollapsed</code> setting:\n<ul><li><code>false</code>: (default) collapses are converted to empty geometries\n(and removed if they are elements of collections)</li><li><code>true</code>: collapses are converted to a valid geometry of lower dimension</li></ul></li></ol>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryMapper.IMapOp.yml\" sourcestartlinenumber=\"1\">An interface for geometry functions used for mapping.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryMapper.MapOp.yml\" sourcestartlinenumber=\"1\">Standard implementation of a geometry mapping</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryMapper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryMapper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryMapper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryMapper.yml\" sourcestartlinenumber=\"1\">Methods to map various collections\nof <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s\nvia defined mapping functions.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.GeometryTransformer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.GeometryTransformer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.GeometryTransformer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.GeometryTransformer.yml\" sourcestartlinenumber=\"1\">A framework for processes which transform an input <code>Geometry</code> into\nan output <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>, possibly changing its structure and type(s).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.LineStringExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.LineStringExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.LineStringExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.LineStringExtracter.yml\" sourcestartlinenumber=\"1\">Extracts all the <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> elements from a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.LinearComponentExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.LinearComponentExtracter.yml\" sourcestartlinenumber=\"1\">Extracts all the 1-dimensional (<xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>) components from a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nFor polygonal geometries, this will extract all the component <xref href=\"NetTopologySuite.Geometries.LinearRing\" data-throw-if-not-resolved=\"false\"></xref>s.\nIf desired, <xref href=\"NetTopologySuite.Geometries.LinearRing\" data-throw-if-not-resolved=\"false\"></xref>s can be forced to be returned as <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.Matrix.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.Matrix.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.Matrix",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.Matrix.yml\" sourcestartlinenumber=\"1\">Implements some 2D matrix operations (in particular, solving systems of linear equations).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException.yml\" sourcestartlinenumber=\"1\">Indicates that an <xref href=\"NetTopologySuite.Geometries.Utilities.AffineTransformation\" data-throw-if-not-resolved=\"false\"></xref> is non-invertible.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.PointExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.PointExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.PointExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.PointExtracter.yml\" sourcestartlinenumber=\"1\">Extracts all the 0-dimensional (<code>Point</code>) components from a <code>Geometry</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.PolygonExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.PolygonExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.PolygonExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.PolygonExtracter.yml\" sourcestartlinenumber=\"1\">Extracts all the <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref> elements from a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.PolygonalExtracter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.PolygonalExtracter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.PolygonalExtracter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.PolygonalExtracter.yml\" sourcestartlinenumber=\"1\">.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor.yml\" sourcestartlinenumber=\"1\">A visitor to <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> elements which  components, which\nallows short-circuiting when a defined condition holds.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.SineStarFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.SineStarFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities.SineStarFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Geometries.Utilities.SineStarFactory.yml\" sourcestartlinenumber=\"1\">Creates geometries which are shaped like multi-armed stars with each arm shaped like a sine wave.\nThese kinds of geometries are useful as a more complex geometry for testing algorithms.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.Utilities.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.Utilities.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries.Utilities",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.Utilities.md\" sourcestartlinenumber=\"5\">Provides classes that parse and modify Geometry objects.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Geometries.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Geometries.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Geometries",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"5\">Contains the <xref href=\"NetTopologySuite.Geometries.Geometry\">Geometry</xref> class hierarchy.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"7\">The .Net Topology Suite (NTS) is a .Net API that implements a core set of spatial data operations using an explicit precision model and robust geometric algorithms. NTS is intended to be used in the development of applications that support the validation, cleaning, integration and querying of spatial datasets.<br>\nIt is a direct port of the popular Java Topology Suite (JTS).</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"10\">NTS attempts to implement the OpenGIS Simple Features Specification (SFS) as accurately as possible. In some cases the SFS is unclear or omits a specification; in this case NTS attempts to choose a reasonable and consistent alternative. Differences from and elaborations of the SFS are documented in this specification.</p>\n<h1 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"12\">Package Specification</h1>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"13\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"13\">Java Topology Suite Technical Specifications</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"14\"><a href=\"http://www.opengis.org/techno/specs.htm\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Geometries.md\" sourcestartlinenumber=\"14\">OpenGIS Simple Features Specification for SQL</a></li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Depth.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Depth.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Depth",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Depth.yml\" sourcestartlinenumber=\"1\">A Depth object records the topological depth of the sides\nof an Edge for up to two Geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.DirectedEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.DirectedEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.DirectedEdge",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.DirectedEdgeStar.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.DirectedEdgeStar.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.DirectedEdgeStar",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.DirectedEdgeStar.yml\" sourcestartlinenumber=\"1\">A DirectedEdgeStar is an ordered list of outgoing DirectedEdges around a node.\nIt supports labelling the edges as well as linking the edges to form both\nMaximalEdgeRings and MinimalEdgeRings.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Edge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Edge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Edge",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeEnd.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeEnd.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeEnd",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.EdgeEnd.yml\" sourcestartlinenumber=\"1\">Models the end of an edge incident on a node.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeEndStar.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeEndStar.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeEndStar",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.EdgeEndStar.yml\" sourcestartlinenumber=\"1\">A EdgeEndStar is an ordered list of EdgeEnds around a node.\nThey are maintained in CCW order (starting with the positive x-axis) around the node\nfor efficient lookup and topology building.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeIntersection.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeIntersection.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeIntersection",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.EdgeIntersection.yml\" sourcestartlinenumber=\"1\">An EdgeIntersection represents a point on an\nedge which intersects with another edge.\nThe intersection may either be a single point, or a line segment\n(in which case this point is the start of the line segment)\nThe label attached to this intersection point applies to\nthe edge from this point forwards, until the next\nintersection or the end of the edge.\nThe intersection point must be precise.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeIntersectionList.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeIntersectionList.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeIntersectionList",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.EdgeIntersectionList.yml\" sourcestartlinenumber=\"1\">A list of edge intersections along an Edge.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeList.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeList.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeList",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.EdgeList.yml\" sourcestartlinenumber=\"1\">A EdgeList is a list of Edges.  It supports locating edges\nthat are point-wise equals to a target edge.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeNodingValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeNodingValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeNodingValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.EdgeNodingValidator.yml\" sourcestartlinenumber=\"1\">Validates that a collection of <xref href=\"NetTopologySuite.GeometriesGraph.Edge\" data-throw-if-not-resolved=\"false\"></xref> is correctly noded.\nThrows an appropriate exception if an noding error is found.\n<remarks>\nUses <xref href=\"NetTopologySuite.Noding.FastNodingValidator\" data-throw-if-not-resolved=\"false\"></xref> to perform the validation.\n</remarks></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.EdgeRing.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.EdgeRing.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.EdgeRing",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.GeometryGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.GeometryGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.GeometryGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.GeometryGraph.yml\" sourcestartlinenumber=\"1\">A GeometryGraph is a graph that models a given Geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.GraphComponent.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.GraphComponent.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.GraphComponent",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.GraphComponent.yml\" sourcestartlinenumber=\"1\">A GraphComponent is the parent class for the objects'\nthat form a graph.  Each GraphComponent can carry a\nLabel.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector.yml\" sourcestartlinenumber=\"1\">An <code>EdgeSetIntersector</code> computes all the intersections between the\nedges in the set.  It adds the computed intersections to each edge\nthey are found on.  It may be used in two scenarios:\ndetermining the internal intersections between a single set of edges\ndetermining the mutual intersections between two different sets of edges\nIt uses a <code>SegmentIntersector</code> to compute the intersections between\nsegments and to record statistics about what kinds of intersections were found.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.MonotoneChain.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.MonotoneChain.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.MonotoneChain",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge.yml\" sourcestartlinenumber=\"1\">MonotoneChains are a way of partitioning the segments of an edge to\nallow for fast searching of intersections.\nThey have the following properties:\nthe segments within a monotone chain will never intersect each other, and\nthe envelope of any contiguous subset of the segments in a monotone chain\nis simply the envelope of the endpoints of the subset.\nProperty 1 means that there is no need to test pairs of segments from within\nthe same monotone chain for intersection.\nProperty 2 allows\nbinary search to be used to find the intersection points of two monotone chains.\nFor many types of real-world data, these properties eliminate a large number of\nsegment comparisons, producing substantial speed gains.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer.yml\" sourcestartlinenumber=\"1\">MonotoneChains are a way of partitioning the segments of an edge to\nallow for fast searching of intersections.</p>\n<p>\nSpecifically, a sequence of contiguous line segments\nis a monotone chain if all the vectors defined by the oriented segments\nlies in the same quadrant.\n</p><p>\nMonotone Chains have the following useful properties:\nthe segments within a monotone chain will never intersect each other, and\nthe envelope of any contiguous subset of the segments in a monotone chain\nis simply the envelope of the endpoints of the subset.\nProperty 1 means that there is no need to test pairs of segments from within\nthe same monotone chain for intersection.\nProperty 2 allows\nbinary search to be used to find the intersection points of two monotone chains.\nFor many types of real-world data, these properties eliminate a large number of\nsegment comparisons, producing substantial speed gains.\n</p>\n<p>\nNote that due to the efficient intersection test, there is no need to limit the size\nof chains to obtain fast performance.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.SegmentIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.SegmentIntersector.yml\" sourcestartlinenumber=\"1\">Computes the intersection of line segments,\nand adds the intersection to the edges containing the segments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector.yml\" sourcestartlinenumber=\"1\">Finds all intersections in one or two sets of edges,\nusing the straightforward method of\ncomparing all segments.\nThis algorithm is too slow for production use, but is useful for testing purposes.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector.yml\" sourcestartlinenumber=\"1\">Finds all intersections in one or two sets of edges,\nusing an x-axis sweepline algorithm in conjunction with Monotone Chains.\nWhile still O(n^2) in the worst case, this algorithm\ndrastically improves the average-case time.\nThe use of MonotoneChains as the items in the index\nseems to offer an improvement in performance over a sweep-line alone.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector.yml\" sourcestartlinenumber=\"1\">Finds all intersections in one or two sets of edges,\nusing a simple x-axis sweepline algorithm.\nWhile still O(n^2) in the worst case, this algorithm\ndrastically improves the average-case time.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.SweepLineEvent",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.SweepLineSegment.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.SweepLineSegment.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index.SweepLineSegment",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Index.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Index.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Index",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.GeometriesGraph.Index.md\" sourcestartlinenumber=\"5\">Contains classes that implement indexes for performing noding on geometry graph edges.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Label.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Label.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Label",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Label.yml\" sourcestartlinenumber=\"1\">A <code>Label</code> indicates the topological relationship of a component\nof a topology graph to a given <code>Geometry</code>.\nThis class supports labels for relationships to two <code>Geometry</code>s,\nwhich is sufficient for algorithms for binary operations.\nTopology graphs support the concept of labeling nodes and edges in the graph.\nThe label of a node or edge specifies its topological relationship to one or\nmore geometries.  (In fact, since NTS operations have only two arguments labels\nare required for only two geometries).  A label for a node or edge has one or\ntwo elements, depending on whether the node or edge occurs in one or both of the\ninput <code>Geometry</code>s.  Elements contain attributes which categorize the\ntopological location of the node or edge relative to the parent\n<code>Geometry</code>; that is, whether the node or edge is in the interior,\nboundary or exterior of the <code>Geometry</code>.  Attributes have a value\nfrom the set <code>{Interior, Boundary, Exterior}</code>.  In a node each\nelement has a single attribute <code>On</code>. For an edge each element has a\ntriplet of attributes <code>Left, On, Right</code>.\nIt is up to the client code to associate the 0 and 1 <code>TopologyLocation</code>s\nwith specific geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Node.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Node.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Node",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.NodeFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.NodeFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.NodeFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.NodeFactory.yml\" sourcestartlinenumber=\"1\">A Factory to create <xref href=\"NetTopologySuite.GeometriesGraph.Node\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.NodeMap.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.NodeMap.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.NodeMap",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.NodeMap.yml\" sourcestartlinenumber=\"1\">A map of nodes, indexed by the coordinate of the node.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.PlanarGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.PlanarGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.PlanarGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.PlanarGraph.yml\" sourcestartlinenumber=\"1\">The computation of the <code>IntersectionMatrix</code> relies on the use of a structure\ncalled a &quot;topology graph&quot;. The topology graph contains nodes and edges\ncorresponding to the nodes and line segments of a <code>Geometry</code>. Each\nnode and edge in the graph is labeled with its topological location relative to\nthe source point.\nNote that there is no requirement that points of self-intersection be a vertex.\nThus to obtain a correct topology graph, <code>Geometry</code>s must be\nself-noded before constructing their graphs.\nTwo fundamental operations are supported by topology graphs:\nComputing the intersections between all the edges and nodes of a single graph\nComputing the intersections between the edges and nodes of two different graphs</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Position.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Position.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Position",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.Position.yml\" sourcestartlinenumber=\"1\">A Position indicates the position of a Location relative to a graph component\n(Node, Edge, or Area).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.Positions.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.Positions.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.Positions",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.QuadrantOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.QuadrantOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.QuadrantOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.QuadrantOp.yml\" sourcestartlinenumber=\"1\">Utility functions for working with quadrants, which are numbered as follows:</p>\n<p>\n1 | 0\n--+--\n2 | 3\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.TopologyLocation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.TopologyLocation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph.TopologyLocation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.GeometriesGraph.TopologyLocation.yml\" sourcestartlinenumber=\"1\">A TopologyLocation is the labelling of a\nGraphComponent's topological relationship to a single Geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.GeometriesGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.GeometriesGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.GeometriesGraph",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.GeometriesGraph.md\" sourcestartlinenumber=\"5\">Contains classes that implement topology graphs.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.GeometriesGraph.md\" sourcestartlinenumber=\"7\">The Net Topology Suite (NTS) is a .Net API that implements a core set of spatial data operations using an explicit precision model and robust geometric algorithms. NTS is intended to be used in the development of applications that support the validation, cleaning, integration and querying of spatial datasets.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.GeometriesGraph.md\" sourcestartlinenumber=\"9\">NTS attempts to implement the OpenGIS Simple Features Specification (SFS) as accurately as possible. In some cases the SFS is unclear or omits a specification; in this case NTS attempts to choose a reasonable and consistent alternative. Differences from and elaborations of the SFS are documented in this specification.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.BEBinaryWriter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.BEBinaryWriter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.BEBinaryWriter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.BEBinaryWriter.yml\" sourcestartlinenumber=\"1\">Extends the <xref href=\"System.IO.BinaryWriter\" data-throw-if-not-resolved=\"false\"></xref> class to allow writing values in the BigEndian format.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.BiEndianBinaryReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.BiEndianBinaryReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.BiEndianBinaryReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.BiEndianBinaryReader.yml\" sourcestartlinenumber=\"1\">Extends the <xref href=\"System.IO.BinaryReader\" data-throw-if-not-resolved=\"false\"></xref> class to allow reading values in the specified format.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.ByteOrder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.ByteOrder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.ByteOrder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.ByteOrder.yml\" sourcestartlinenumber=\"1\">Byte order</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.GML2.GMLReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.GML2.GMLReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.GML2.GMLReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.GML2.GMLReader.yml\" sourcestartlinenumber=\"1\">Reads a GML document and creates a representation of the features based on NetTopologySuite model.\nUses GML 2.1.1 <code>Geometry.xsd</code> schema for base for features.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.GML2.GMLWriter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.GML2.GMLWriter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.GML2.GMLWriter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.GML2.GMLWriter.yml\" sourcestartlinenumber=\"1\">Writes the GML representation of the features of NetTopologySuite model.\nUses GML 2.1.1 <code>Geometry.xsd</code> schema for base for features.\n<remarks>\nThanks to <a href=\"http//www.codeplex.com/Wiki/View.aspx?ProjectName=MsSqlSpatial\">rstuven</a> for improvements :)\n</remarks></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.GML2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.GML2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.GML2",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.GML2.md\" sourcestartlinenumber=\"5\">Classes to read and write the GML2 geometry format.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.GML3.GML3Writer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.GML3.GML3Writer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.GML3.GML3Writer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.GML3.GML3Writer.yml\" sourcestartlinenumber=\"1\">Writes the GML representation of the features of NetTopologySuite model.\nUses GML 3.2.2 <code>gml.xsd</code> schema for base for features.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.GML3.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.GML3.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.GML3",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.GeometryType.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.GeometryType.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.GeometryType",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.GeometryType.yml\" sourcestartlinenumber=\"1\">Lightweight class that handles OGC Geometry type declaration</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.KML.KMLReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.KML.KMLReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.KML.KMLReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.KML.KMLReader.yml\" sourcestartlinenumber=\"1\">Constructs <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> objects from the OGC KML representation.\nWorks only with KML geometry elements and may also parse attributes within these elements</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.KML.KMLWriter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.KML.KMLWriter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.KML.KMLWriter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.KML.KMLWriter.yml\" sourcestartlinenumber=\"1\">Writes a formatted string containing the KML representation\nof a JTS <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nThe output is KML fragments which can be substituted\nwherever the KML <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> abstract\nelement can be used.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.KML.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.KML.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.KML",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.OrdinateFormat.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.OrdinateFormat.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.OrdinateFormat",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.OrdinateFormat.yml\" sourcestartlinenumber=\"1\">Formats numeric values for ordinates\nin a consistent, accurate way.</p>\n<p></p>\nThe format has the following characteristics:\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.ParseException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.ParseException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.ParseException",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.ParseException.yml\" sourcestartlinenumber=\"1\">Thrown by a <code>WKTReader</code> when a parsing problem occurs.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKBGeometryTypes.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKBGeometryTypes.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKBGeometryTypes",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKBGeometryTypes.yml\" sourcestartlinenumber=\"1\">WKB Geometry Types</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKBHexFileReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKBHexFileReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKBHexFileReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKBHexFileReader.yml\" sourcestartlinenumber=\"1\">Reads a sequence of {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.IO.WKBHexFileReader.yml\" sourcestartlinenumber=\"1\"></xref> Geometry}s in WKBHex format\nfrom a text file.\nEach WKBHex geometry must be on a single line\nThe geometries in the file may be separated by any amount\nof whitespace and newlines.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKBReader.CoordinateSystem.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKBReader.CoordinateSystem.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKBReader.CoordinateSystem",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKBReader.CoordinateSystem.yml\" sourcestartlinenumber=\"1\">WKB Coordinate Systems</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKBReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKBReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKBReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKBReader.yml\" sourcestartlinenumber=\"1\">Converts a Well-Known Binary byte data to a <code>Geometry</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKBWriter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKBWriter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKBWriter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKBWriter.yml\" sourcestartlinenumber=\"1\">Writes a Well-Known Binary byte data representation of a <code>Geometry</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKTConstants.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKTConstants.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKTConstants",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKTConstants.yml\" sourcestartlinenumber=\"1\">Constants used in the WKT (Well-Known Text) format.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKTFileReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKTFileReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKTFileReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKTFileReader.yml\" sourcestartlinenumber=\"1\">Reads a sequence of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s in WKT format from a text file.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKTReader.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKTReader.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKTReader",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKTReader.yml\" sourcestartlinenumber=\"1\">Converts a Well-Known Text string to a <code>Geometry</code>.</p>\n<p sourcefile=\"obj/api/NetTopologySuite.IO.WKTReader.yml\" sourcestartlinenumber=\"3\">The <code>WKTReader</code> allows\nextracting <code>Geometry</code> objects from either input streams or\ninternal strings. This allows it to function as a parser to read <code>Geometry</code>\nobjects from text blocks embedded in other data formats (e.g. XML).</p>\n<p sourcefile=\"obj/api/NetTopologySuite.IO.WKTReader.yml\" sourcestartlinenumber=\"8\">The Well-known\nText format is defined in the <a href=\"http://www.opengis.org/techno/specs.htm\">\nOpenGIS Simple Features Specification for SQL</a> .</p>\n<p></p>\nAs of version 2.0, NTS can read WKT syntax\nwhich specifies coordinate dimension Z, M or ZM as modifiers(e.g.POINT Z)\nor in the name of the geometry type(e.g.LINESTRINGZM).\nIf the coordinate dimension is specified it will be set in the created geometry.\nIf the coordinate dimension is not specified, the default behaviour is to\ncreate XYZ geometry(this is backwards compatible with older JTS versions).\nThis can be altered to create XY geometry by\nsetting <xref href=\"NetTopologySuite.IO.WKTReader.IsOldNtsCoordinateSyntaxAllowed\" data-throw-if-not-resolved=\"false\"></xref> to <code>false</code>.\n<p></p>\nA reader can be set to ensure the input is structurally valid\nby setting <xref href=\"NetTopologySuite.IO.WKTReader.FixStructure\" data-throw-if-not-resolved=\"false\"></xref> to <code>true</code>.\nThis ensures that geometry can be constructed without errors due to missing coordinates.\nThe created geometry may still be topologically invalid.\n<p></p>\nNOTE:  There is an inconsistency in the SFS.\nThe WKT grammar states that <code>MultiPoints</code> are represented by\n<code>MULTIPOINT ( ( x y), (x y) )</code>,\nbut the examples show <code>MultiPoint</code>s as <code>MULTIPOINT ( x y, x y )</code>.\nOther implementations follow the latter syntax, so NTS will adopt it as well.\nA <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,\nto allow it to create <code>Geometry</code> objects of the appropriate\nimplementation. In particular, the <code>GeometryFactory</code> will\ndetermine the <code>PrecisionModel</code> and <code>SRID</code> that is used.\nThe <code>WKTReader</code> will convert the input numbers to the precise\ninternal representation.\n<remarks>\n<xref href=\"NetTopologySuite.IO.WKTReader\" data-throw-if-not-resolved=\"false\"></xref> reads also non-standard <xref href=\"NetTopologySuite.IO.WKTConstants.LINEARRING\" data-throw-if-not-resolved=\"false\"></xref> tags.\n</remarks>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.WKTWriter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.WKTWriter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO.WKTWriter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.IO.WKTWriter.yml\" sourcestartlinenumber=\"1\">Outputs the textual representation of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nThe <xref href=\"NetTopologySuite.IO.WKTWriter\" data-throw-if-not-resolved=\"false\"></xref> outputs coordinates rounded to the precision\nmodel. No more than the maximum number of necessary decimal places will be\noutput.\nThe Well-known Text format is defined in the <a href=\"http://www.opengis.org/techno/specs.htm\">OpenGIS Simple Features\nSpecification for SQL</a>.\nA non-standard &quot;LINEARRING&quot; tag is used for LinearRings. The WKT spec does\nnot define a special tag for LinearRings. The standard tag to use is\n&quot;LINESTRING&quot;.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.IO.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.IO.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.IO",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"5\">Contains the interfaces for converting JTS objects to and from other formats.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"7\">The Net Topology Suite (NTS) is a .Net API that implements a core set of spatial data operations using an explicit precision model and robust geometric algorithms. NTS is intended to be used in the development of applications that support the validation, cleaning, integration and querying of spatial datasets.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"9\">NTS attempts to implement the OpenGIS Simple Features Specification (SFS) as accurately as possible. In some cases the SFS is unclear or omits a specification; in this case NTS attempts to choose a reasonable and consistent alternative. Differences from and elaborations of the SFS are documented in this specification.</p>\n<h1 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"11\">Package Specification</h1>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"12\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"12\">Java Topology Suite Technical Specifications</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"13\"><a href=\"http://www.opengis.org/techno/specs.htm\" sourcefile=\"overwrite/namespaces/NetTopologySuite.IO.md\" sourcestartlinenumber=\"13\">OpenGIS Simple Features Specification for SQL</a></li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.ArrayListVisitor-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.ArrayListVisitor-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.ArrayListVisitor<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.ArrayListVisitor-1.yml\" sourcestartlinenumber=\"1\">Builds an array of all visited items.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.ArrayListVisitor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.ArrayListVisitor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.ArrayListVisitor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.ArrayListVisitor.yml\" sourcestartlinenumber=\"1\">Builds an array of all visited items.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.Bintree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.Bintree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.Bintree<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Bintree.Bintree-1.yml\" sourcestartlinenumber=\"1\">An <code>BinTree</code> (or &quot;Binary Interval Tree&quot;)\nis a 1-dimensional version of a quadtree.\nIt indexes 1-dimensional intervals (which may\nbe the projection of 2-D objects on an axis).\nIt supports range searching\n(where the range may be a single point).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.Bintree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.Bintree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.Bintree",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.Interval.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.Interval.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.Interval",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Bintree.Interval.yml\" sourcestartlinenumber=\"1\">Represents an (1-dimensional) closed interval on the Real number line.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.Key.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.Key.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.Key",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Bintree.Key.yml\" sourcestartlinenumber=\"1\">A Key is a unique identifier for a node in a tree.\nIt contains a lower-left point and a level number. The level number\nis the power of two for the size of the node envelope.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.Node-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.Node-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.Node<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Bintree.Node-1.yml\" sourcestartlinenumber=\"1\">A node of a <code>Bintree</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.NodeBase-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.NodeBase-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.NodeBase<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Bintree.NodeBase-1.yml\" sourcestartlinenumber=\"1\">The base class for nodes in a <code>Bintree</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.Root-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.Root-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree.Root<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Bintree.Root-1.yml\" sourcestartlinenumber=\"1\">The root node of a single <code>Bintree</code>.\nIt is centred at the origin,\nand does not have a defined extent.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Bintree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Bintree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Bintree",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Index.Bintree.md\" sourcestartlinenumber=\"5\">Contains classes that implement a Binary Interval Tree index</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Chain.MonotoneChain.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Chain.MonotoneChain.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Chain.MonotoneChain",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Chain.MonotoneChain.yml\" sourcestartlinenumber=\"1\">MonotoneChains are a way of partitioning the segments of a linestring to\nallow for fast searching of intersections.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Chain.MonotoneChainBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Chain.MonotoneChainBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Chain.MonotoneChainBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Chain.MonotoneChainBuilder.yml\" sourcestartlinenumber=\"1\">Constructs <xref href=\"NetTopologySuite.Index.Chain.MonotoneChain\" data-throw-if-not-resolved=\"false\"></xref>s\nfor sequences of <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Chain.MonotoneChainOverlapAction",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Chain.MonotoneChainOverlapAction.yml\" sourcestartlinenumber=\"1\">The action for the internal iterator for performing\noverlap queries on a MonotoneChain.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Chain.MonotoneChainSelectAction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Chain.MonotoneChainSelectAction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Chain.MonotoneChainSelectAction",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Chain.MonotoneChainSelectAction.yml\" sourcestartlinenumber=\"1\">The action for the internal iterator for performing\nenvelope select queries on a MonotoneChain.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Chain.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Chain.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Chain",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Index.Chain.md\" sourcestartlinenumber=\"5\">Contains classes that implement Monotone Chains</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.HPRtree.HPRtree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.HPRtree.HPRtree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.HPRtree.HPRtree<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.HPRtree.HPRtree-1.yml\" sourcestartlinenumber=\"1\">A Hilbert-Packed R-tree.  This is a static R-tree\nwhich is packed by using the Hilbert ordering\nof the tree items.</p>\n<p></p>\nThe tree is constructed by sorting the items\nby the Hilbert code of the midpoint of their envelope.\nThen, a set of internal layers is created recursively\nas follows:\n<ul><li><span class=\"term\">The items/nodes of the previous are partitioned into blocks of size <code>nodeCapacity</code></span></li><li><span class=\"term\">For each block a layer node is created with range equal to the envelope of the items/nodess in the block</span></li></ul>\nThe internal layers are stored using an array to\nstore the node bounds.\nThe link between a node and its children is\nstored implicitly in the indexes of the array.\nFor efficiency, the offsets to the layers\nwithin the node array are pre-computed and stored.\n<p></p>\nNOTE: Based on performance testing,\nthe HPRtree is somewhat faster than the STRtree.\nIt should also be more memory-efficent,\ndue to fewer object allocations.\n<p></p>\nHowever, it is not clear whether this\nwill produce a significant improvement\nfor use in JTS operations.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.HPRtree.HilbertEncoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.HPRtree.HilbertEncoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.HPRtree.HilbertEncoder",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.HPRtree.Item-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.HPRtree.Item-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.HPRtree.Item<T>",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.HPRtree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.HPRtree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.HPRtree",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IIndexVisitor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IIndexVisitor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IIndexVisitor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.IIndexVisitor.yml\" sourcestartlinenumber=\"1\">A visitor for nodes and items in an index.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IItemVisitor-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IItemVisitor-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IItemVisitor<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.IItemVisitor-1.yml\" sourcestartlinenumber=\"1\">A visitor for items in a <xref href=\"NetTopologySuite.Index.ISpatialIndex%601\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.ILimitingItemVisitor-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.ILimitingItemVisitor-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.ILimitingItemVisitor<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.ILimitingItemVisitor-1.yml\" sourcestartlinenumber=\"1\">A visitor for items in a <xref href=\"NetTopologySuite.Index.ISpatialIndex%601\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p><b>Not used, commited by accident!</b></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.ISpatialIndex-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.ISpatialIndex-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.ISpatialIndex<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.ISpatialIndex-1.yml\" sourcestartlinenumber=\"1\">The basic insertion and query operations supported by classes\nimplementing spatial index algorithms.\nA spatial index typically provides a primary filter for range rectangle queries. A\nsecondary filter is required to test for exact intersection. Of course, this\nsecondary filter may consist of other tests besides intersection, such as\ntesting other kinds of spatial relationships.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.ISpatialIndexEx-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.ISpatialIndexEx-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.ISpatialIndexEx<T>",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeBranchNode-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeBranchNode-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IntervalRTree.IntervalRTreeBranchNode<T>",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeLeafNode-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeLeafNode-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IntervalRTree.IntervalRTreeLeafNode<T>",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode-1.NodeComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode-1.NodeComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode<T>.NodeComparator",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode<T>",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree-1.yml\" sourcestartlinenumber=\"1\">A static index on a set of 1-dimensional intervals,\nusing an R-Tree packed based on the order of the interval midpoints.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.IntervalRTree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.IntervalRTree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.IntervalRTree",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.KdTree.IKdNodeVisitor-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.KdTree.IKdNodeVisitor-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.KdTree.IKdNodeVisitor<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.KdTree.IKdNodeVisitor-1.yml\" sourcestartlinenumber=\"1\">A visitor for <xref href=\"NetTopologySuite.Index.KdTree.KdNode%601\" data-throw-if-not-resolved=\"false\"></xref>s in a <xref href=\"NetTopologySuite.Index.KdTree.KdTree%601\" data-throw-if-not-resolved=\"false\"></xref> index.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.KdTree.KdNode-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.KdTree.KdNode-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.KdTree.KdNode<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.KdTree.KdNode-1.yml\" sourcestartlinenumber=\"1\">A node of a <xref href=\"NetTopologySuite.Index.KdTree.KdTree%601\" data-throw-if-not-resolved=\"false\"></xref>, which represents one or more points in the same location.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.KdTree.KdTree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.KdTree.KdTree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.KdTree.KdTree<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.KdTree.KdTree-1.yml\" sourcestartlinenumber=\"1\">An implementation of a\n<a href=\"https://en.wikipedia.org/wiki/K-d_tree\"> KD - Tree </a>\nover two dimensions(X and Y).\nKD-trees provide fast range searching and fast lookup for point data.\nThe tree is built dynamically by inserting points.\nThe tree supports queries by range and for point equality.\nFor querying an internal stack is used instead of recursion to avoid overflow.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.KdTree.KdTreeExtensions.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.KdTree.KdTreeExtensions.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.KdTree.KdTreeExtensions",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.KdTree.KdTreeExtensions.yml\" sourcestartlinenumber=\"1\">Extensions methods for the <xref href=\"NetTopologySuite.Index.KdTree.KdTree%601\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.KdTree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.KdTree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.KdTree",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.DoubleBits.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.DoubleBits.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.DoubleBits",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.DoubleBits.yml\" sourcestartlinenumber=\"1\">DoubleBits manipulates Double numbers\nby using bit manipulation and bit-field extraction.\nFor some operations (such as determining the exponent)\nthis is more accurate than using mathematical operations\n(which suffer from round-off error).\nThe algorithms and constants in this class\napply only to IEEE-754 double-precision floating point format.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.ExcludingItemVisitor-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.ExcludingItemVisitor-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.ExcludingItemVisitor<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.ExcludingItemVisitor-1.yml\" sourcestartlinenumber=\"1\">Item visitor that specifically excludes a predefined area.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.IntervalSize.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.IntervalSize.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.IntervalSize",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.IntervalSize.yml\" sourcestartlinenumber=\"1\">Provides a test for whether an interval is\nso small it should be considered as zero for the purposes of\ninserting it into a binary tree.\nThe reason this check is necessary is that round-off error can\ncause the algorithm used to subdivide an interval to fail, by\ncomputing a midpoint value which does not lie strictly between the\nendpoints.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.Key.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.Key.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.Key",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.Key.yml\" sourcestartlinenumber=\"1\">A Key is a unique identifier for a node in a quadtree.\nIt contains a lower-left point and a level number. The level number\nis the power of two for the size of the node envelope.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.Node-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.Node-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.Node<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.Node-1.yml\" sourcestartlinenumber=\"1\">Represents a node of a <code>Quadtree</code>.  Nodes contain\nitems which have a spatial extent corresponding to the node's position\nin the quadtree.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.NodeBase-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.NodeBase-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.NodeBase<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.NodeBase-1.yml\" sourcestartlinenumber=\"1\">The base class for nodes in a <code>Quadtree</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.Quadtree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.Quadtree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.Quadtree<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.Quadtree-1.yml\" sourcestartlinenumber=\"1\">A Quadtree is a spatial index structure for efficient range querying\nof items bounded by 2D rectangles.<br>\n<xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s can be indexed by using their <xref href=\"NetTopologySuite.Geometries.Envelope\" data-throw-if-not-resolved=\"false\"></xref>s.<br>\nAny type of object can also be indexed, as long as it has an extent that can be\nrepresented by an <xref href=\"NetTopologySuite.Geometries.Envelope\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nThis Quadtree index provides a <b>primary filter</b>\nfor range rectangle queries.  The various query methods return a list of\nall items which <i>may</i> intersect the query rectangle.  Note that\nit may thus return items which do <b>not</b> in fact intersect the query rectangle.\nA secondary filter is required to test for actual intersection\nbetween the query rectangle and the envelope of each candidate item.\nThe secondary filter may be performed explicitly,\nor it may be provided implicitly by subsequent operations executed on the items\n(for instance, if the index query is followed by computing a spatial predicate\nbetween the query geometry and tree items,\nthe envelope intersection check is performed automatically.\n<p></p>\nThis implementation does not require specifying the extent of the inserted\nitems beforehand.  It will automatically expand to accommodate any extent\nof dataset.\n<p></p>\nThis data structure is also known as an <code>MX-CIF quadtree</code>\nfollowing the terminology usage of Samet and others.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.Root-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.Root-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree.Root<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Quadtree.Root-1.yml\" sourcestartlinenumber=\"1\">QuadRoot is the root of a single Quadtree.\nIt is centred at the origin,\nand does not have a defined extent.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Quadtree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Quadtree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Quadtree",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Index.Quadtree.md\" sourcestartlinenumber=\"5\">Contains classes that implement a Quadtree spatial index</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.AbstractNode-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.AbstractNode-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.AbstractNode<T, TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.AbstractNode-2.yml\" sourcestartlinenumber=\"1\">A node of an <xref href=\"NetTopologySuite.Index.Strtree.AbstractSTRtree%602\" data-throw-if-not-resolved=\"false\"></xref>. A node is one of:</p>\n<ul><li>empty</li><li>an <i>interior node</i> containing child <xref href=\"NetTopologySuite.Index.Strtree.AbstractNode%602\" data-throw-if-not-resolved=\"false\"></xref>s</li><li>a <i>leaf node</i> containing data items (<xref href=\"NetTopologySuite.Index.Strtree.ItemBoundable%602\" data-throw-if-not-resolved=\"false\"></xref>s).</li></ul>\nA node stores the bounds of its children, and its level within the index tree.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.AbstractSTRtree-2.IIntersectsOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.AbstractSTRtree-2.IIntersectsOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.AbstractSTRtree<T, TItem>.IIntersectsOp",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.AbstractSTRtree-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.AbstractSTRtree-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.AbstractSTRtree<T, TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.AbstractSTRtree-2.yml\" sourcestartlinenumber=\"1\">Base class for STRtree and SIRtree. STR-packed R-trees are described in:\nP. Rigaux, Michel Scholl and Agnes Voisard. <i>Spatial Databases With\nApplication To GIS</i>. Morgan Kaufmann, San Francisco, 2002.</p>\n<p>\nThis implementation is based on <xref href=\"NetTopologySuite.Geometries.IBoundable%602\" data-throw-if-not-resolved=\"false\"></xref>s rather than just <xref href=\"NetTopologySuite.Index.Strtree.AbstractNode%602\" data-throw-if-not-resolved=\"false\"></xref>s,\nbecause the STR algorithm operates on both nodes and\ndata, both of which are treated as <xref href=\"NetTopologySuite.Geometries.IBoundable%602\" data-throw-if-not-resolved=\"false\"></xref>s.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.EnvelopeDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.EnvelopeDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.EnvelopeDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.EnvelopeDistance.yml\" sourcestartlinenumber=\"1\">Utility functions for working with <xref href=\"NetTopologySuite.Geometries.Envelope\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.GeometryItemDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.GeometryItemDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.GeometryItemDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.GeometryItemDistance.yml\" sourcestartlinenumber=\"1\">An <xref href=\"NetTopologySuite.Index.Strtree.IItemDistance%602\" data-throw-if-not-resolved=\"false\"></xref> function for\nitems which are <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"NetTopologySuite.Geometries.Geometry.Distance(NetTopologySuite.Geometries.Geometry)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p></p>\nTo make this distance function suitable for\nusing to query a single index tree,\nthe distance metric is <i>anti-reflexive</i>.\nThat is, if the two arguments are the same Geometry object,\nthe distance returned is <xref href=\"System.Double.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.IItemDistance-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.IItemDistance-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.IItemDistance<T, TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.IItemDistance-2.yml\" sourcestartlinenumber=\"1\">A function method which computes the distance\nbetween two <xref href=\"NetTopologySuite.Geometries.IBoundable%602\" data-throw-if-not-resolved=\"false\"></xref>s in an <xref href=\"NetTopologySuite.Index.Strtree.STRtree%601\" data-throw-if-not-resolved=\"false\"></xref>.\nUsed for Nearest Neighbour searches.</p>\n<p></p>\nTo make a distance function suitable for\nquerying a single index tree\nvia <xref href=\"NetTopologySuite.Index.Strtree.STRtree%601.NearestNeighbour(NetTopologySuite.Index.Strtree.IItemDistance%7bNetTopologySuite.Geometries.Envelope%2c%600%7d)\" data-throw-if-not-resolved=\"false\"></xref>,\nthe function should have a non-zero <i>reflexive distance</i>.\nThat is, if the two arguments are the same object,\nthe distance returned should be non-zero.\nIf it is required that only pairs of <b>distinct</b> items be returned,\nthe distance function must be <i>anti-reflexive</i>,\nand must return <xref href=\"System.Double.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> for identical arguments.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.Interval.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.Interval.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.Interval",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.Interval.yml\" sourcestartlinenumber=\"1\">A contiguous portion of 1D-space. Used internally by SIRtree.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.ItemBoundable-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.ItemBoundable-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.ItemBoundable<T, TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.ItemBoundable-2.yml\" sourcestartlinenumber=\"1\">Boundable wrapper for a non-Boundable spatial object. Used internally by\nAbstractSTRtree.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.SIRtree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.SIRtree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.SIRtree<TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.SIRtree-1.yml\" sourcestartlinenumber=\"1\">One-dimensional version of an STR-packed R-tree. SIR stands for\n&quot;Sort-Interval-Recursive&quot;. STR-packed R-trees are described in:\nP. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With\nApplication To GIS. Morgan Kaufmann, San Francisco, 2002.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.STRtree-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.STRtree-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree.STRtree<TItem>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Strtree.STRtree-1.yml\" sourcestartlinenumber=\"1\">A query-only R-tree created using the Sort-Tile-Recursive (STR) algorithm.\nFor two-dimensional spatial data.</p>\n<p></p>\nThe STR packed R-tree is simple to implement and maximizes space\nutilization; that is, as many leaves as possible are filled to capacity.\nOverlap between nodes is far less than in a basic R-tree.\nHowever, the index is semi-static; once the tree has been built\n(which happens automatically upon the first query), items may\nnot be added.<br>\nItems may be removed from the tree using <xref href=\"NetTopologySuite.Index.Strtree.STRtree%601.Remove(NetTopologySuite.Geometries.Envelope%2c%600)\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nDescribed in: P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With\nApplication To GIS. Morgan Kaufmann, San Francisco, 2002.\n<p></p>\n<b>Note that inserting items into a tree is not thread-safe.</b>\nInserting performed on more than one thread must be synchronized externally.\n<p></p>\nQuerying a tree is thread-safe. The building phase is done synchronously,\nand querying is stateless.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Strtree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Strtree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Strtree",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Index.Strtree.md\" sourcestartlinenumber=\"5\">Contains 2-D and 1-D versions of the Sort-Tile-Recursive (STR) tree, a query-only R-tree.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Sweepline.SweepLineEvent.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Sweepline.SweepLineEvent.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Sweepline.SweepLineEvent",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Sweepline.SweepLineEvents.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Sweepline.SweepLineEvents.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Sweepline.SweepLineEvents",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Sweepline.SweepLineIndex.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Sweepline.SweepLineIndex.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Sweepline.SweepLineIndex",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.Sweepline.SweepLineIndex.yml\" sourcestartlinenumber=\"1\">A sweepline implements a sorted index on a set of intervals.\nIt is used to compute all overlaps between the interval in the index.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Sweepline.SweepLineInterval.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Sweepline.SweepLineInterval.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Sweepline.SweepLineInterval",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.Sweepline.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.Sweepline.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.Sweepline",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Index.Sweepline.md\" sourcestartlinenumber=\"5\">Contains classes which implement a sweepline algorithm for scanning geometric data structures.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.VertexSequencePackedRtree.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.VertexSequencePackedRtree.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index.VertexSequencePackedRtree",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Index.VertexSequencePackedRtree.yml\" sourcestartlinenumber=\"1\">A semi-static spatial index for points which occur\nin a spatially-coherent sequence.\nIn particular, this is suitable for indexing the vertices\nof a {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Index.VertexSequencePackedRtree.yml\" sourcestartlinenumber=\"4\"></xref> LineString} or {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Index.VertexSequencePackedRtree.yml\" sourcestartlinenumber=\"4\"></xref> Polygon} ring.</p>\n<p></p>\nThe index is constructed in a batch fashion on a given sequence of coordinates.\nCoordinates can be removed via the {@link #remove(int)} method.\n<p></p>\nNote that this index queries only the individual points\nof the input coordinate sequence,\n<b>not</b> any line segments which might be lie between them.\n<p></p>\nThe input coordinate array is read-only,\nand is not changed when vertices are removed.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Index.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Index.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Index",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Index.md\" sourcestartlinenumber=\"5\">Provides classes for various kinds of spatial indexes.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.ExtractLineByLocation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.ExtractLineByLocation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.ExtractLineByLocation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.ExtractLineByLocation.yml\" sourcestartlinenumber=\"1\">Extracts the subline of a linear <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> between\ntwo <xref href=\"NetTopologySuite.LinearReferencing.LinearLocation\" data-throw-if-not-resolved=\"false\"></xref>s on the line.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LengthIndexOfPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LengthIndexOfPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LengthIndexOfPoint",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LengthIndexedLine.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LengthIndexedLine.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LengthIndexedLine",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LengthIndexedLine.yml\" sourcestartlinenumber=\"1\">Supports linear referencing along a linear <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\nusing the length along the line as the index.\nNegative length values are taken as measured in the reverse direction\nfrom the end of the geometry.\nOut-of-range index values are handled by clamping\nthem to the valid range of values.\nNon-simple lines (i.e. which loop back to cross or touch\nthemselves) are supported.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LengthLocationMap.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LengthLocationMap.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LengthLocationMap",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LengthLocationMap.yml\" sourcestartlinenumber=\"1\">Computes the <xref href=\"NetTopologySuite.LinearReferencing.LinearLocation\" data-throw-if-not-resolved=\"false\"></xref> for a given length\nalong a linear <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\nNegative lengths are measured in reverse from end of the linear geometry.\nOut-of-range values are clamped.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LinearGeometryBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LinearGeometryBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LinearGeometryBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LinearGeometryBuilder.yml\" sourcestartlinenumber=\"1\">Builds a linear geometry (<xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref>)\nincrementally (point-by-point).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LinearIterator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LinearIterator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LinearIterator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LinearIterator.yml\" sourcestartlinenumber=\"1\">An iterator over the components and coordinates of a linear geometry\n(<xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s and <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LinearLocation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LinearLocation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LinearLocation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LinearLocation.yml\" sourcestartlinenumber=\"1\">Represents a location along a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref>.<br>\nThe referenced geometry is not maintained within this location,\nbut must be provided for operations which require it.\nVarious methods are provided to manipulate the location value\nand query the geometry it references.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LocationIndexOfLine.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LocationIndexOfLine.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LocationIndexOfLine",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LocationIndexOfLine.yml\" sourcestartlinenumber=\"1\">Determines the location of a subline along a linear <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nThe location is reported as a pair of <xref href=\"NetTopologySuite.LinearReferencing.LinearLocation\" data-throw-if-not-resolved=\"false\"></xref>s.\nNOTE: Currently this algorithm is not guaranteed to\nreturn the correct substring in some situations where\nan endpoint of the test line occurs more than once in the input line.\n(However, the common case of a ring is always handled correctly).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LocationIndexOfPoint.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LocationIndexOfPoint.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LocationIndexOfPoint",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LocationIndexOfPoint.yml\" sourcestartlinenumber=\"1\">Computes the <xref href=\"NetTopologySuite.LinearReferencing.LinearLocation\" data-throw-if-not-resolved=\"false\"></xref> of the point\non a linear <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>nearest a given <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>.\nThe nearest point is not necessarily unique; this class\nalways computes the nearest point closest\nto the start of the geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.LocationIndexedLine.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.LocationIndexedLine.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing.LocationIndexedLine",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.LinearReferencing.LocationIndexedLine.yml\" sourcestartlinenumber=\"1\">Supports linear referencing along a linear <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\nusing <xref href=\"NetTopologySuite.LinearReferencing.LinearLocation\" data-throw-if-not-resolved=\"false\"></xref>s as the index.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.LinearReferencing.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.LinearReferencing.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.LinearReferencing",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"5\">Contains classes and interfaces implementing linear referencing on linear geometries</p>\n<h2 id=\"linear-referencing\" sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"7\">Linear Referencing</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"8\">Linear Referencing is a way of defining positions along linear geometries (LineStrings and MultiLineStrings). It is used extensively in linear network systems. There are numerous possible Linear Referencing Methods which can be used to define positions along linear geometry. This package supports two:</p>\n<h2 id=\"linear-location\" sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"10\">Linear Location</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"11\">A linear location is a triple (component index, segment index, segment fraction) which precisely specifies a point on a linear geometry. It allows for efficient mapping of the index value to actual coordinate values.</p>\n<h2 id=\"length\" sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"13\">Length</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"14\">The natural concept of using the length along the geometry to specify a position.</p>\n<h1 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"16\">Package Specification</h1>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"17\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.LinearReferencing.md\" sourcestartlinenumber=\"17\">Java Topology Suite Technical Specifications</li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.DD.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.DD.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.DD",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.DD.yml\" sourcestartlinenumber=\"1\">Implements extended-precision floating-point numbers\nwhich maintain 106 bits (approximately 30 decimal digits) of precision.</p>\n<p></p>\nA DoubleDouble uses a representation containing two double-precision values.\nA number x is represented as a pair of doubles, x.hi and x.lo,\nsuch that the number represented by x is x.hi + x.lo, where\n<pre>\n    |x.lo| &lt;= 0.5*ulp(x.hi)\n</pre>\nand ulp(y) means \"unit in the last place of y\".\nThe basic arithmetic operations are implemented using\nconvenient properties of IEEE-754 floating-point arithmetic.\n<p></p>\nThe range of values which can be represented is the same as in IEEE-754.\nThe precision of the representable numbers\nis twice as great as IEEE-754 double precision.\n<p></p>\nThe correctness of the arithmetic algorithms relies on operations\nbeing performed with standard IEEE-754 double precision and rounding.\nThis is the Java standard arithmetic model, but for performance reasons\nJava implementations are not\nconstrained to using this standard by default.\nSome processors (notably the Intel Pentium architecture) perform\nfloating point operations in (non-IEEE-754-standard) extended-precision.\nA JVM implementation may choose to use the non-standard extended-precision\nas its default arithmetic mode.\nTo prevent this from happening, this code uses the\nJava <tt>strictfp</tt> modifier,\nwhich forces all operations to take place in the standard IEEE-754 rounding model.\n<p></p>\nThe API provides both a set of value-oriented operations\nand a set of mutating operations.\nValue-oriented operations treat DoubleDouble values as\nimmutable; operations on them return new objects carrying the result\nof the operation.  This provides a simple and safe semantics for\nwriting DoubleDouble expressions.  However, there is a performance\npenalty for the object allocations required.\nThe mutable interface updates object values in-place.\nIt provides optimum memory performance, but requires\ncare to ensure that aliasing errors are not created\nand constant values are not changed.\n<p></p>\nThis implementation uses algorithms originally designed variously by\nKnuth, Kahan, Dekker, and Linnainmaa.\nDouglas Priest developed the first C implementation of these techniques.\nOther more recent C++ implementation are due to Keith M. Briggs and David Bailey et al.\n<h3>References</h3>\n<ul><li>Priest, D., <i>Algorithms for Arbitrary Precision Floating Point Arithmetic</i>,\nin P. Kornerup and D. Matula, Eds., Proc. 10th Symposium on Computer Arithmetic,\nIEEE Computer Society Press, Los Alamitos, Calif., 1991.</li><li>Yozo Hida, Xiaoye S. Li and David H. Bailey,\n<i>Quad-Double Arithmetic: Algorithms, Implementation, and Application</i>,\nmanuscript, Oct 2000; Lawrence Berkeley National Laboratory Report BNL-46996.</li><li>David Bailey, <i>High Precision Software Directory</i>;\n<tt>http://crd.lbl.gov/~dhbailey/mpdist/index.html</tt></li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.MathUtil.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.MathUtil.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.MathUtil",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.MathUtil.yml\" sourcestartlinenumber=\"1\">Various utility functions for mathematical and numerical operations.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.Matrix.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.Matrix.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.Matrix",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.Matrix.yml\" sourcestartlinenumber=\"1\">Implements some 2D matrix operations\n(in particular, solving systems of linear equations).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.Plane.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.Plane.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.Plane",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.Plane.yml\" sourcestartlinenumber=\"1\">Enumeration for the 3 coordinate planes</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.Plane3D.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.Plane3D.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.Plane3D",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.Plane3D.yml\" sourcestartlinenumber=\"1\">Models a plane in 3-dimensional Cartesian space.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.Vector2D.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.Vector2D.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.Vector2D",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.Vector2D.yml\" sourcestartlinenumber=\"1\">A 2-dimensional mathematical vector represented by double-precision X and Y components.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.Vector3D.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.Vector3D.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.Vector3D",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.Vector3D.yml\" sourcestartlinenumber=\"1\">Represents a vector in 3-dimensional Cartesian space.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.VectorMath.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.VectorMath.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics.VectorMath",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Mathematics.VectorMath.yml\" sourcestartlinenumber=\"1\">Functions for performing vector mathematics.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Mathematics.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Mathematics.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Mathematics",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.BasicSegmentString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.BasicSegmentString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.BasicSegmentString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.BasicSegmentString.yml\" sourcestartlinenumber=\"1\">Represents a read-only list of contiguous line segments.\nThis can be used for detection of intersections or nodes.\n<xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s can carry a context object, which is useful\nfor preserving topological or parentage information.</p>\n<p></p>\nIf adding nodes is required use <xref href=\"NetTopologySuite.Noding.NodedSegmentString\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.BoundaryChainNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.BoundaryChainNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.BoundaryChainNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.BoundaryChainNoder.yml\" sourcestartlinenumber=\"1\">A noder which extracts chains of boundary segments\nas {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Noding.BoundaryChainNoder.yml\" sourcestartlinenumber=\"2\"></xref> SegmentString}s from a polygonal coverage.\nBoundary segments are those which are not duplicated in the input polygonal coverage.\nExtracting chains of segments minimize the number of segment strings created,\nwhich produces a more efficient topological graph structure.</p>\n<p></p>\nThis enables fast overlay of polygonal coverages in <xref href=\"NetTopologySuite.Coverage.CoverageUnion\" data-throw-if-not-resolved=\"false\"></xref>.\nUsing this noder is faster than <xref href=\"NetTopologySuite.Noding.SegmentExtractingNoder\" data-throw-if-not-resolved=\"false\"></xref>\nand <xref href=\"NetTopologySuite.Noding.BoundarySegmentNoder\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nNo precision reduction is carried out.\nIf that is required, another noder must be used (such as a snap-rounding noder),\nor the input must be precision-reduced beforehand.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.BoundarySegmentNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.BoundarySegmentNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.BoundarySegmentNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.BoundarySegmentNoder.yml\" sourcestartlinenumber=\"1\">A noder which extracts boundary line segments\nas <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>.\nBoundary segments are those which are not duplicated in the input.\nIt is appropriate for use with valid polygonal coverages.</p>\n<p></p>\nNo precision reduction is carried out.\nIf that is required, another noder must be used (such as a snap-rounding noder),\nor the input must be precision-reduced beforehand.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.FastNodingValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.FastNodingValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.FastNodingValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.FastNodingValidator.yml\" sourcestartlinenumber=\"1\">Validates that a collection of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s is correctly noded.\nIndexing is used to improve performance.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.FastSegmentSetIntersectionFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.FastSegmentSetIntersectionFinder.yml\" sourcestartlinenumber=\"1\">Finds if two sets of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s intersect.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.INodableSegmentString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.INodableSegmentString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.INodableSegmentString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.INodableSegmentString.yml\" sourcestartlinenumber=\"1\">An interface for classes which support adding nodes to a segment string.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.INoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.INoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.INoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.INoder.yml\" sourcestartlinenumber=\"1\">Computes all intersections between segments in a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s.\nIntersections found are represented as <xref href=\"NetTopologySuite.Noding.SegmentNode\" data-throw-if-not-resolved=\"false\"></xref>s and added to the\n<xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s in which they occur.\nAs a final step in the noding a new set of segment strings split at the nodes may be returned.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.ISegmentIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.ISegmentIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.ISegmentIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.ISegmentIntersector.yml\" sourcestartlinenumber=\"1\">Processes possible intersections detected by a <xref href=\"NetTopologySuite.Noding.INoder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.ISegmentSetMutualIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.ISegmentSetMutualIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.ISegmentSetMutualIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.ISegmentSetMutualIntersector.yml\" sourcestartlinenumber=\"1\">An intersector for the red-blue intersection problem.\nIn this class of line arrangement problem,\ntwo disjoint sets of linestrings are intersected.</p>\n<p></p>\nImplementing classes must provide a way\nof supplying the base set of segment strings to\ntest against (e.g. in the constructor,\nfor straightforward thread-safety).\n<p></p>\nIn order to allow optimizing processing,\nthe following condition is assumed to hold for each set:\n<p sourcefile=\"obj/api/NetTopologySuite.Noding.ISegmentSetMutualIntersector.yml\" sourcestartlinenumber=\"13\">Implementations can take advantage of this fact to optimize processing\n(i.e. by avoiding testing for intersections between linestrings\nbelonging to the same set).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.ISegmentString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.ISegmentString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.ISegmentString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.ISegmentString.yml\" sourcestartlinenumber=\"1\">An interface for classes which represent a sequence of contiguous line segments.\nSegmentStrings can carry a context object, which is useful\nfor preserving topological or parentage information.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.InteriorIntersectionFinderAdder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.InteriorIntersectionFinderAdder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.InteriorIntersectionFinderAdder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.InteriorIntersectionFinderAdder.yml\" sourcestartlinenumber=\"1\">Finds <b>interior</b> intersections\nbetween line segments in <xref href=\"NetTopologySuite.Noding.NodedSegmentString\" data-throw-if-not-resolved=\"false\"></xref>s,\nand adds them as nodes\nusing <xref href=\"NetTopologySuite.Noding.NodedSegmentString.AddIntersection(NetTopologySuite.Algorithm.LineIntersector%2cSystem.Int32%2cSystem.Int32%2cSystem.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.\nThis class is used primarily for Snap-Rounding.\nFor general-purpose noding, use <xref href=\"NetTopologySuite.Noding.IntersectionAdder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.IntersectionAdder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.IntersectionAdder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.IntersectionAdder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.IntersectionAdder.yml\" sourcestartlinenumber=\"1\">Computes the possible intersections between two line segments in <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s\nand adds them to each string\nusing <xref href=\"NetTopologySuite.Noding.NodedSegmentString.AddIntersection(NetTopologySuite.Algorithm.LineIntersector%2cSystem.Int32%2cSystem.Int32%2cSystem.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.IteratedNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.IteratedNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.IteratedNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.IteratedNoder.yml\" sourcestartlinenumber=\"1\">Nodes a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s completely.\nThe set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s is fully noded;\ni.e. noding is repeated until no further intersections are detected.</p>\n<p>\nIterated noding using a <xref href=\"NetTopologySuite.Geometries.PrecisionModels.Floating\" data-throw-if-not-resolved=\"false\"></xref> precision model is not guaranteed to converge,\ndue to round off error. This problem is detected and an exception is thrown.\nClients can choose to rerun the noding using a lower precision model.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.MCIndexNoder.SegmentOverlapAction",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.MCIndexNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.MCIndexNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.MCIndexNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.MCIndexNoder.yml\" sourcestartlinenumber=\"1\">Nodes a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s using a index based\non <xref href=\"NetTopologySuite.Index.Chain.MonotoneChain\" data-throw-if-not-resolved=\"false\"></xref>s and a <xref href=\"NetTopologySuite.Index.ISpatialIndex%601\" data-throw-if-not-resolved=\"false\"></xref>.\nThe <xref href=\"NetTopologySuite.Index.ISpatialIndex%601\" data-throw-if-not-resolved=\"false\"></xref> used should be something that supports\nenvelope (range) queries efficiently (such as a <code>Quadtree</code>&quot;\nor <xref href=\"NetTopologySuite.Index.HPRtree.HPRtree%601\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nThe noder supports using an overlap tolerance distance.\nThis allows determining segment intersection using a buffer for uses\ninvolving snapping with a distance tolerance.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.SegmentOverlapAction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.SegmentOverlapAction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.SegmentOverlapAction",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.SegmentOverlapAction.yml\" sourcestartlinenumber=\"1\">Segment overlap action class</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector.yml\" sourcestartlinenumber=\"1\">Intersects two sets of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s using a index based\non <xref href=\"NetTopologySuite.Index.Chain.MonotoneChain\" data-throw-if-not-resolved=\"false\"></xref>s and a <xref href=\"NetTopologySuite.Index.ISpatialIndex%601\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nThread-safe and immutable.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.NodedSegmentString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.NodedSegmentString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.NodedSegmentString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.NodedSegmentString.yml\" sourcestartlinenumber=\"1\">Represents a list of contiguous line segments, and supports noding the segments.\nThe line segments are represented by an array of <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s.\nIntended to optimize the noding of contiguous segments by\nreducing the number of allocated objects.\n<xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s can carry a context object, which is useful\nfor preserving topological or parentage information.\nAll noded substrings are initialized with the same context object.</p>\n<p></p>\nFor read-only applications use <xref href=\"NetTopologySuite.Noding.BasicSegmentString\" data-throw-if-not-resolved=\"false\"></xref>,\nwhich is (slightly)more lightweight.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.NodingIntersectionFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.NodingIntersectionFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.NodingIntersectionFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.NodingIntersectionFinder.yml\" sourcestartlinenumber=\"1\">Finds non-noded intersections in a set of {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Noding.NodingIntersectionFinder.yml\" sourcestartlinenumber=\"1\"></xref> SegmentString}s,\nif any exist.</p>\n<p></p>\nNon-noded intersections include:\n<p sourcefile=\"obj/api/NetTopologySuite.Noding.NodingIntersectionFinder.yml\" sourcestartlinenumber=\"6\">The finder can be limited to finding only interior intersections\nby setting <xref href=\"NetTopologySuite.Noding.NodingIntersectionFinder.InteriorIntersectionsOnly\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nBy default only the first intersection is found,\nbut all can be found by setting <xref href=\"NetTopologySuite.Noding.NodingIntersectionFinder.FindAllIntersections\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.NodingValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.NodingValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.NodingValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.NodingValidator.yml\" sourcestartlinenumber=\"1\">Validates that a collection of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s is correctly noded.\nThrows an appropriate exception if an noding error is found.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Octant.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Octant.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Octant",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Octant.yml\" sourcestartlinenumber=\"1\">Methods for computing and working with <xref href=\"NetTopologySuite.Noding.Octants\" data-throw-if-not-resolved=\"false\"></xref> of the Cartesian plane.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Octants.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Octants.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Octants",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Octants.yml\" sourcestartlinenumber=\"1\">Octants in the Cartesian plane.\nOctants are numbered as follows:</p>\n <p>\n  \\2|1/\n 3 \\|/ 0\n ---+--\n 4 /|\\ 7\n  /5|6\\\n</p>\n If line segments lie along a coordinate axis, the octant is the lower of the two possible values.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.OrientedCoordinateArray.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.OrientedCoordinateArray.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.OrientedCoordinateArray",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.OrientedCoordinateArray.yml\" sourcestartlinenumber=\"1\">Allows comparing <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref> arrays in an orientation-independent way.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.ScaledNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.ScaledNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.ScaledNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.ScaledNoder.yml\" sourcestartlinenumber=\"1\">Wraps a <xref href=\"NetTopologySuite.Noding.INoder\" data-throw-if-not-resolved=\"false\"></xref> and transforms its input into the integer domain.\nThis is intended for use with Snap-Rounding noders,\nwhich typically are only intended to work in the integer domain.</p>\n<p>\nClients should be aware that rescaling can involve loss of precision,\nwhich can cause zero-length line segments to be created.\nThese in turn can cause problems when used to build a planar graph.\nThis situation should be checked for and collapsed segments removed if necessary.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentExtractingNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentExtractingNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentExtractingNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentExtractingNoder.yml\" sourcestartlinenumber=\"1\">A noder which extracts all line segments\nas <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s.\nThis enables fast overlay of geometries which are known to be already fully noded.\nIn particular, it provides fast union of polygonal and linear coverages.\nUnioning a noded set of lines is an effective way\nto perform line merging and line dissolving.</p>\n<p></p>\nNo precision reduction is carried out. \nIf that is required, another noder must be used (such as a snap-rounding noder),\nor the input must be precision-reduced beforehand.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentIntersectionDetector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentIntersectionDetector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentIntersectionDetector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentIntersectionDetector.yml\" sourcestartlinenumber=\"1\">Detects and records an intersection between two <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s,\nif one exists.  Only a single intersection is recorded.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentNode.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentNode.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentNode",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentNode.yml\" sourcestartlinenumber=\"1\">Represents an intersection point between two <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentNodeList.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentNodeList.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentNodeList",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentNodeList.yml\" sourcestartlinenumber=\"1\">A list of the <xref href=\"NetTopologySuite.Noding.SegmentNode\" data-throw-if-not-resolved=\"false\"></xref>s present along a noded <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentPointComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentPointComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentPointComparator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentPointComparator.yml\" sourcestartlinenumber=\"1\">Implements a robust method of comparing the relative position of two points along the same segment.\nThe coordinates are assumed to lie &quot;near&quot; the segment.\nThis means that this algorithm will only return correct results\nif the input coordinates have the same precision and correspond to rounded values\nof exact coordinates lying on the segment.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentStringDissolver.ISegmentStringMerger.yml\" sourcestartlinenumber=\"1\">A merging strategy which can be used to update the context data of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s\nwhich are merged during the dissolve process.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentStringDissolver.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentStringDissolver.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentStringDissolver",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentStringDissolver.yml\" sourcestartlinenumber=\"1\">Dissolves a noded collection of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s to produce\na set of merged linework with unique segments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentStringEx.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentStringEx.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentStringEx",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentStringEx.yml\" sourcestartlinenumber=\"1\">Extension methods to mimic JTS' default methods on SegmentString interface</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SegmentStringUtil.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SegmentStringUtil.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SegmentStringUtil",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SegmentStringUtil.yml\" sourcestartlinenumber=\"1\">Utility methods for processing <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SimpleNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SimpleNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SimpleNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SimpleNoder.yml\" sourcestartlinenumber=\"1\">Nodes a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s by\nperforming a brute-force comparison of every segment to every other one.\nThis has n^2 performance, so is too slow for use on large numbers of segments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector.yml\" sourcestartlinenumber=\"1\">Intersects two sets of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s using\nbrute-force comparison.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.SinglePassNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.SinglePassNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.SinglePassNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.SinglePassNoder.yml\" sourcestartlinenumber=\"1\">Base class for <xref href=\"NetTopologySuite.Noding.INoder\" data-throw-if-not-resolved=\"false\"></xref>s which make a single pass to find intersections.\nThis allows using a custom <xref href=\"NetTopologySuite.Noding.ISegmentIntersector\" data-throw-if-not-resolved=\"false\"></xref>\n(which for instance may simply identify intersections, rather than insert them).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snap.SnappingIntersectionAdder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snap.SnappingIntersectionAdder.yml\" sourcestartlinenumber=\"1\">Finds intersections between line segments which are being snapped,\nand adds them as nodes.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snap.SnappingNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snap.SnappingNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snap.SnappingNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snap.SnappingNoder.yml\" sourcestartlinenumber=\"1\">Nodes a set of segment strings\nsnapping vertices and intersection points together if\nthey lie within the given snap tolerance distance.\nVertices take priority over intersection points for snapping.\nInput segment strings are generally only split at true node points\n(i.e.the output segment strings are of maximal length in the output arrangement).</p>\n<p></p>\nThe snap tolerance should be chosen to be as small as possible\nwhile still producing a correct result.\nIt probably only needs to be small enough to eliminate\n\"nearly-coincident\" segments, for which intersection points cannot be computed accurately.\nThis implies a factor of about 10e-12\nsmaller than the magnitude of the segment coordinates.\n<p></p>\nWith an appropriate snap tolerance this algorithm appears to be very robust.\nSo far no failure cases have been found,\ngiven a small enough snap tolerance.\n<p></p>\nThe correctness of the output is not verified by this noder.\nIf required this can be done by <xref href=\"NetTopologySuite.Noding.ValidatingNoder\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snap.SnappingPointIndex.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snap.SnappingPointIndex.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snap.SnappingPointIndex",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snap.SnappingPointIndex.yml\" sourcestartlinenumber=\"1\">An index providing fast creation and lookup of snap points.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snap.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snap.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snap",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.GeometryNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.GeometryNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.GeometryNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.GeometryNoder.yml\" sourcestartlinenumber=\"1\">Nodes the linework in a list of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s using Snap-Rounding\nto a given <xref href=\"NetTopologySuite.Geometries.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>\nThe input coordinates do not need to be rounded to the\nprecision model.\nAll output coordinates are rounded to the precision model.\n</p><p>\nThis class does <b>not</b> dissolve the output linework,\nso there may be duplicate linestrings in the output.\nSubsequent processing (e.g. polygonization) may require\nthe linework to be unique.  Using <code>UnaryUnion</code> is one way\nto do this (although this is an inefficient approach).\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.HotPixel.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.HotPixel.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.HotPixel",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.HotPixel.yml\" sourcestartlinenumber=\"1\">Implements a &quot;hot pixel&quot; as used in the Snap Rounding algorithm.\nA hot pixel is a square region centred\non the rounded valud of the coordinate given,\nand of width equal to the size of the scale factor.\nIt is a partially open region, which contains\nthe interior of the tolerance square and\nthe boundary\n<b>minus</b> the top and right segments.\nThis ensures that every point of the space lies in a unique hot pixel.\nIt also matches the rounding semantics for numbers.</p>\n<p></p>\nThe hot pixel operations are all computed in the integer domain\nto avoid rounding problems.\n<p></p>\nHot Pixels support being marked as nodes.\nThis is used to prevent introducing nodes at line vertices\nwhich do not have other lines snapped to them.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.MCIndexPointSnapper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.MCIndexPointSnapper.yml\" sourcestartlinenumber=\"1\">&quot;Snaps&quot; all <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s in a <xref href=\"NetTopologySuite.Index.ISpatialIndex%601\" data-throw-if-not-resolved=\"false\"></xref> containing\n<xref href=\"NetTopologySuite.Index.Chain.MonotoneChain\" data-throw-if-not-resolved=\"false\"></xref>s to a given <xref href=\"NetTopologySuite.Noding.Snapround.HotPixel\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.MCIndexSnapRounder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.MCIndexSnapRounder.yml\" sourcestartlinenumber=\"1\">Uses Snap Rounding to compute a rounded,\nfully noded arrangement from a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s.\nImplements the Snap Rounding technique described in\npapers by Hobby, Guibas and Marimont, and Goodrich et al.\nSnap Rounding assumes that all vertices lie on a uniform grid;\nhence the precision model of the input must be fixed precision,\nand all the input vertices must be rounded to that precision.</p>\n<p></p>\nThis implementation uses a monotone chains and a spatial index to\nspeed up the intersection tests.\n<p></p>\n<h3>KNOWN BUGS</h3>\nThis implementation is not fully robust.\ninstead.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.SimpleSnapRounder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.SimpleSnapRounder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.SimpleSnapRounder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.SimpleSnapRounder.yml\" sourcestartlinenumber=\"1\">Uses Snap Rounding to compute a rounded,\nfully noded arrangement from a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n<p></p>\nImplements the Snap Rounding technique described in\nthe papers by Hobby, Guibas &amp; Marimont, and Goodrich et al.\nSnap Rounding enforces that all vertices lie on a uniform grid,\nwhich is determined by the provided <xref href=\"NetTopologySuite.Geometries.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.\nInput vertices do not have to be rounded to this grid;\nthis will be done during the snap-rounding process.\n<p></p>\nThis implementation uses simple iteration over the line segments.\nThis is not an efficient approach for large sets of segments.\nThis implementation appears to be fully robust using an integer precision model.\nIt will function with non-integer precision models, but the\nresults are not 100% guaranteed to be correctly noded.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder.yml\" sourcestartlinenumber=\"1\">Finds intersections between line segments which will be snap-rounded,\nand adds them as nodes to the segments.</p>\n<p></p>\nIntersections are detected and computed using full precision.\nSnapping takes place in a subsequent phase.\n<p></p>\nThe intersection points are recorded, so that HotPixels can be created for them.\n<p></p>\nTo avoid robustness issues with vertices which lie very close to line segments\na heuristic is used:\nnodes are created if a vertex lies within a tolerance distance\nof the interior of a segment.\nThe tolerance distance is chosen to be significantly below the snap-rounding grid size.\nThis has empirically proven to eliminate noding failures.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.SnapRoundingNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.SnapRoundingNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround.SnapRoundingNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.Snapround.SnapRoundingNoder.yml\" sourcestartlinenumber=\"1\">Uses Snap Rounding to compute a rounded,\nfully noded arrangement from a set of <xref href=\"NetTopologySuite.Noding.ISegmentString\" data-throw-if-not-resolved=\"false\"></xref>s,\nin a performant way, and avoiding unnecessary noding.</p>\n<p></p>\nImplements the Snap Rounding technique described in \nthe papers by Hobby, Guibas &amp; Marimont, and Goodrich et al.\nSnap Rounding enforces that all output vertices lie on a uniform grid,\nwhich is determined by the provided <xref href=\"NetTopologySuite.Geometries.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nInput vertices do not have to be rounded to the grid beforehand; \nthis is done during the snap-rounding process.\nIn fact, rounding cannot be done a priori,\nsince rounding vertices by themselves can distort the rounded topology\nof the arrangement (i.e. by moving segments away from hot pixels\nthat would otherwise intersect them, or by moving vertices\nacross segments).\n<p></p>\nTo minimize the number of introduced nodes,\nthe Snap-Rounding Noder avoids creating nodes\nat edge vertices if there is no intersection or snap at that location.\nHowever, if two different input edges contain identical segments,\neach of the segment vertices will be noded.\nThis still provides fully-noded output.\nThis is the same behaviour provided by other noders,\nsuch as <xref href=\"NetTopologySuite.Noding.MCIndexNoder\" data-throw-if-not-resolved=\"false\"></xref>\nand <xref href=\"NetTopologySuite.Noding.Snap.SnappingNoder\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.Snapround.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.Snapround.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.Snapround",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Noding.Snapround.md\" sourcestartlinenumber=\"5\">Contains classes to implement the Snap Rounding algorithm for noding linestrings.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.ValidatingNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.ValidatingNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding.ValidatingNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Noding.ValidatingNoder.yml\" sourcestartlinenumber=\"1\">A wrapper for <xref href=\"NetTopologySuite.Noding.INoder\" data-throw-if-not-resolved=\"false\"></xref>s which validates\nthe output arrangement is correctly noded.\nAn arrangement of line segments is fully noded if\nthere is no line segment\nwhich has another segment intersecting its interior.\nIf the noding is not correct, a <xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref> is thrown\nwith details of the first invalid location found.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Noding.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Noding.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Noding",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Noding.md\" sourcestartlinenumber=\"5\">Classes to compute nodings for arrangements of line segments and line segment sequences.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.NtsGeometryServices.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.NtsGeometryServices.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.NtsGeometryServices",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.NtsGeometryServices.yml\" sourcestartlinenumber=\"1\">A geometry service provider class</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.BoundaryOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.BoundaryOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.BoundaryOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.BoundaryOp.yml\" sourcestartlinenumber=\"1\">Computes the boundary of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.\nAllows specifying the <xref href=\"NetTopologySuite.Algorithm.IBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref> to be used.\nThis operation will always return a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> of the appropriate\ndimension for the boundary (even if the input geometry is empty).\nThe boundary of zero-dimensional geometries (Points) is\nalways the empty <xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder.yml\" sourcestartlinenumber=\"1\">Creates all the raw offset curves for a buffer of a <code>Geometry</code>.\nRaw curves need to be noded together and polygonized to form the final buffer area.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a buffer input line to remove concavities with shallow depth.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.BufferOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.BufferOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.BufferOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.BufferOp.yml\" sourcestartlinenumber=\"1\">Computes the buffer of a geometry, for both positive and negative buffer distances.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.BufferParameters.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.BufferParameters.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.BufferParameters",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.BufferParameters.yml\" sourcestartlinenumber=\"1\">A value class containing the parameters which\nspecify how a buffer should be constructed.</p>\n<p></p>\nThe parameters allow control over:\n<ul><li>Quadrant segments (accuracy of approximation for circular arcs)</li><li>End Cap style</li><li>Join style</li><li>Mitre limit</li><li>whether the buffer is single-sided</li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.EndCapStyle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.EndCapStyle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.EndCapStyle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.EndCapStyle.yml\" sourcestartlinenumber=\"1\">End cap style constants</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.JoinStyle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.JoinStyle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.JoinStyle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.JoinStyle.yml\" sourcestartlinenumber=\"1\">Join style constants</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.OffsetCurve.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.OffsetCurve.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.OffsetCurve",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.OffsetCurve.yml\" sourcestartlinenumber=\"1\">Computes an offset curve from a geometry.\nAn offset curve is a linear geometry which is offset a given distance\nfrom the input.\nIf the offset distance is positive the curve lies on the left side of the input;\nif it is negative the curve is on the right side.\nThe curve(s) have the same direction as the input line(s).\nThe result for a zero offset distance is a copy of the input linework.</p>\n<p></p>\nThe offset curve is based on the boundary of the buffer for the geometry\nat the offset distance(see <xref href=\"NetTopologySuite.Operation.Buffer.BufferOp\" data-throw-if-not-resolved=\"false\"></xref>.\nThe normal mode of operation is to return the sections of the buffer boundarywhich lie on the raw offset curve\n(obtained via <xref href=\"NetTopologySuite.Operation.Buffer.OffsetCurve.RawOffset(NetTopologySuite.Geometries.LineString%2cSystem.Double)\" data-throw-if-not-resolved=\"false\"></xref>.\nThe offset curve will contain multiple sections\nif the input self-intersects or has close approaches.The computed sections are ordered along the raw offset curve.\nSections are disjoint.They never self-intersect, but may be rings.\n<ul><li>For a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> the offset curve is a linear geometry\n(<xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref>).</li><li>For a <xref href=\"NetTopologySuite.Geometries.Point\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.MultiPoint\" data-throw-if-not-resolved=\"false\"></xref> the offset curve is an empty <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>.</li><li>For a <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref> the offset curve is the boundary of the polygon buffer (which\nmay be a <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref>).</li><li>For a collection the output is a <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref> containing the offset curves of the elements.</li></ul>\n<p></p>\nIn \"joined\" mode (see {@link #setJoined(boolean)}\nthe sections computed for each input line are joined into a single offset curve line.\nThe joined curve may self-intersect.\nAt larger offset distances the curve may contain \"flat-line\" artifacts\nin places where the input self-intersects.\n<p></p>\nOffset curves support setting the number of quadrant segments,\nthe join style, and the mitre limit(if applicable) via\nthe <xref href=\"NetTopologySuite.Operation.Buffer.BufferParameters\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.OffsetCurveBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.OffsetCurveBuilder.yml\" sourcestartlinenumber=\"1\">Computes the raw offset curve for a\nsingle <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> component (ring, line or point).\nA raw offset curve line is not noded -\nit may contain self-intersections (and usually will).g\nThe final buffer polygon is computed by forming a topological graph\nof all the noded raw curves and tracing outside contours.\nThe points in the raw curve are rounded\nto a given <xref href=\"NetTopologySuite.Geometries.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nNote: this may not produce correct results if the input\ncontains repeated or invalid points.\nRepeated points should be removed before calling.\n<xref href=\"NetTopologySuite.Geometries.CoordinateArrays.RemoveRepeatedOrInvalidPoints(NetTopologySuite.Geometries.Coordinate%5b%5d)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder.yml\" sourcestartlinenumber=\"1\">Creates all the raw offset curves for a buffer of a <code>Geometry</code>.\nRaw curves need to be noded together and polygonized to form the final buffer area.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.OffsetCurveVertexList",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.OffsetCurveVertexList.yml\" sourcestartlinenumber=\"1\">A list of the vertices in a constructed offset curve.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder.yml\" sourcestartlinenumber=\"1\">Computes the raw offset curve for a single <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> component (ring, line or point).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.MaxMidpointDistanceFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.MaxMidpointDistanceFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.MaxMidpointDistanceFilter",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.MaxPointDistanceFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.MaxPointDistanceFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.MaxPointDistanceFilter",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder.yml\" sourcestartlinenumber=\"1\">Finds the approximate maximum distance from a buffer curve to\nthe originating geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator.yml\" sourcestartlinenumber=\"1\">Validates that a given buffer curve lies an appropriate distance\nfrom the input generating it.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator.yml\" sourcestartlinenumber=\"1\">Validates that the result of a buffer operation\nis geometrically correct, within a computed tolerance.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder.yml\" sourcestartlinenumber=\"1\">Computes the Euclidean distance (L2 metric) from a Point to a Geometry.\nAlso computes two points which are separated by the distance.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.PointPairDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.PointPairDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate.PointPairDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.Validate.PointPairDistance.yml\" sourcestartlinenumber=\"1\">Contains a pair of points and the distance between them.\nProvides methods to update with a new point pair with\neither maximum or minimum distance.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.Validate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.Validate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.Validate",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.VariableBuffer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.VariableBuffer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer.VariableBuffer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Buffer.VariableBuffer.yml\" sourcestartlinenumber=\"1\">Creates a buffer polygon with a varying buffer distance\nat each vertex along a line.\nVertex distances may be zero.</p>\n<p></p>\nOnly single linestring is supported as input, since buffer widths\ngenerally need to be specified individually for each line.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Buffer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Buffer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Buffer",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Buffer.md\" sourcestartlinenumber=\"5\">Provides classes for computing buffers of geometries</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter.yml\" sourcestartlinenumber=\"1\">A ConnectedElementPointFilter extracts a single point\nfrom each connected element in a Geometry\n(e.g. a polygon, linestring or point)\nand returns them in a list. The elements of the list are\n<xref href=\"NetTopologySuite.Operation.Distance.GeometryLocation\" data-throw-if-not-resolved=\"false\"></xref>s.\nEmpty geometries do not provide a location item.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.ConnectedElementPointFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.ConnectedElementPointFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.ConnectedElementPointFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.ConnectedElementPointFilter.yml\" sourcestartlinenumber=\"1\">Extracts a single point\nfrom each connected element in a Geometry\n(e.g. a polygon, linestring or point)\nand returns them in a list</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.DistanceOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.DistanceOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.DistanceOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.DistanceOp.yml\" sourcestartlinenumber=\"1\">Computes the distance and\nclosest points between two <code>Geometry</code>s.\nThe distance computation finds a pair of points in the input geometries\nwhich have minimum distance between them.  These points may\nnot be vertices of the geometries, but may lie in the interior of\na line segment. In this case the coordinate computed is a close\napproximation to the exact point.</p>\n<p></p>\nEmpty geometry collection components are ignored.\n<p></p>\nThe algorithms used are straightforward O(n^2)\ncomparisons.  This worst-case performance could be improved on\nby using Voronoi techniques.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.FacetSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.FacetSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.FacetSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.FacetSequence.yml\" sourcestartlinenumber=\"1\">Represents a sequence of facets (points or line segments) of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\nspecified by a subsequence of a <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder.yml\" sourcestartlinenumber=\"1\">Utility class to build facet sequencs STRtrees-</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.GeometryLocation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.GeometryLocation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.GeometryLocation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.GeometryLocation.yml\" sourcestartlinenumber=\"1\">Represents the location of a point on a Geometry.\nMaintains both the actual point location\n(which may not be exact, if the point is not a vertex)\nas well as information about the component\nand segment index where the point occurs.\nLocations inside area Geometrys will not have an associated segment index,\nso in this case the segment index will have the sentinel value of <xref href=\"NetTopologySuite.Operation.Distance.GeometryLocation.InsideArea\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.IndexedFacetDistance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.IndexedFacetDistance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance.IndexedFacetDistance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance.IndexedFacetDistance.yml\" sourcestartlinenumber=\"1\">Computes the distance between the facets (segments and vertices)\nof two <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s\nusing a Branch-and-Bound algorithm.\nThe Branch-and-Bound algorithm operates over a\ntraversal of R-trees built\non the target and the query geometries.</p>\n<p>\nThis approach provides the following benefits:\n<ul><li>\nPerformance is dramatically improved due to the use of the\nR-tree index\nand the pruning due to the Branch-and-Bound approach\n</li><li>\nThe spatial index on the target geometry is cached\nwhich allow reuse in an repeated query situation.</li></ul>\nUsing this technique is usually much more performant\nthan using the brute-force <xref href=\"NetTopologySuite.Geometries.Geometry.Distance(NetTopologySuite.Geometries.Geometry)\" data-throw-if-not-resolved=\"false\"></xref>\nwhen one or both input geometries are large,\nor when evaluating many distance computations against\na single geometry.\n\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Distance.md\" sourcestartlinenumber=\"5\">Provides classes for computing the distance between geometries</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence.yml\" sourcestartlinenumber=\"1\">A <xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref> wrapper which\nprojects 3D coordinates into one of the\nthree Cartesian axis planes,\nusing the standard orthonormal projection\n(i.e. simply selecting the appropriate ordinates into the XY ordinates).\nThe projected data is represented as 2D coordinates.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance3D.Distance3DOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance3D.Distance3DOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance3D.Distance3DOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance3D.Distance3DOp.yml\" sourcestartlinenumber=\"1\">Find two points on two  3D <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s which lie within a given distance,\nor else are the nearest points on the geometries (in which case this also\nprovides the distance between the geometries).</p>\n<p></p>\n3D geometries have vertex Z ordinates defined.\n3D <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref>s are assumed to lie in a single plane (which is enforced if not actually the case).\n3D <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s and <xref href=\"NetTopologySuite.Geometries.Point\" data-throw-if-not-resolved=\"false\"></xref>s may have any configuration.\n<p></p>\nThe distance computation also finds a pair of points in the input geometries\nwhich have the minimum distance between them. If a point lies in the interior\nof a line segment, the coordinate computed is a close approximation to the\nexact point.\n<p></p>\nThe algorithms used are straightforward O(n^2) comparisons. This worst-case\nperformance could be improved on by using Voronoi techniques or spatial\nindexes.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance3D.PlanarPolygon3D",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.yml\" sourcestartlinenumber=\"1\">Models a polygon lying in a plane in 3-dimensional Cartesian space.\nThe polygon representation is supplied\nby a <xref href=\"NetTopologySuite.Operation.Distance3D.PlanarPolygon3D.Polygon\" data-throw-if-not-resolved=\"false\"></xref>,\ncontaining coordinates with XYZ ordinates.\n3D polygons are assumed to lie in a single plane.\nThe plane best fitting the polygon coordinates is\ncomputed and is represented by a <xref href=\"NetTopologySuite.Mathematics.Plane3D\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Distance3D.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Distance3D.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Distance3D",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.GeometryGraphOperation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.GeometryGraphOperation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.GeometryGraphOperation",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.GeometryGraphOperation.yml\" sourcestartlinenumber=\"1\">The base class for operations that require <xref href=\"NetTopologySuite.GeometriesGraph.GeometryGraph\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.IsSimpleOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.IsSimpleOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.IsSimpleOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.IsSimpleOp.yml\" sourcestartlinenumber=\"1\">Tests whether a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> is simple.\nIn general, the SFS specification of simplicity\nfollows the rule:</p>\n<ul><li>\nA Geometry is simple if and only if the only self-intersections are at boundary points.\n</li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.EdgeString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.EdgeString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge.EdgeString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Linemerge.EdgeString.yml\" sourcestartlinenumber=\"1\">A sequence of <code>LineMergeDirectedEdge</code>s forming one of the lines that will\nbe output by the line-merging process.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge.yml\" sourcestartlinenumber=\"1\">A <code>com.vividsolutions.jts.planargraph.DirectedEdge</code> of a <code>LineMergeGraph</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.LineMergeEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.LineMergeEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge.LineMergeEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Linemerge.LineMergeEdge.yml\" sourcestartlinenumber=\"1\">An edge of a <code>LineMergeGraph</code>. The <code>marked</code> field indicates\nwhether this Edge has been logically deleted from the graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.LineMergeGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.LineMergeGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge.LineMergeGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Linemerge.LineMergeGraph.yml\" sourcestartlinenumber=\"1\">A planar graph of edges that is analyzed to sew the edges together. The\n<code>marked</code> flag on <xref href=\"NetTopologySuite.Planargraph.Edge\" data-throw-if-not-resolved=\"false\"></xref>s\nand <xref href=\"NetTopologySuite.Planargraph.Node\" data-throw-if-not-resolved=\"false\"></xref>s indicates whether they have been\nlogically deleted from the graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.LineMerger.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.LineMerger.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge.LineMerger",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Linemerge.LineMerger.yml\" sourcestartlinenumber=\"1\">Sews together a set of fully noded LineStrings.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.LineSequencer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.LineSequencer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge.LineSequencer",
      "Summary": "<p>\nBuilds a sequence from a set of <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s,\nso that they are ordered end to end.\nA sequence is a complete non-repeating list of the linear\ncomponents of the input.  Each linestring is oriented\nso that identical endpoints are adjacent in the list.\n</p>\n<p>\nThe input linestrings may form one or more connected sets.\nThe input linestrings should be correctly noded, or the results may\nnot be what is expected.\nThe output of this method is a single <xref href=\"NetTopologySuite.Geometries.MultiLineString\" data-throw-if-not-resolved=\"false\"></xref>,\ncontaining the ordered linestrings in the sequence.\n</p>\n<p>\nThe sequencing employs the classic 'Eulerian path' graph algorithm.\nSince Eulerian paths are not uniquely determined, further rules are used to\nmake the computed sequence preserve as much as possible of the input ordering.\nWithin a connected subset of lines, the ordering rules are:\n - If there is degree-1 node which is the start\nnode of an linestring, use that node as the start of the sequence.\n - If there is a degree-1 node which is the end\nnode of an linestring, use that node as the end of the sequence.\n - If the sequence has no degree-1 nodes, use any node as the start\n</p>\n<p>\nNot all arrangements of lines can be sequenced.\nFor a connected set of edges in a graph,\nEuler's Theorem states that there is a sequence containing each edge once\nif and only if there are no more than 2 nodes of odd degree.\nIf it is not possible to find a sequence, the <xref href=\"NetTopologySuite.Operation.Linemerge.LineSequencer.IsSequenceable\" data-throw-if-not-resolved=\"false\"></xref>\nproperty will return <code>false</code>.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Linemerge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Linemerge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Linemerge",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.EdgeSetNoder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.EdgeSetNoder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.EdgeSetNoder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.EdgeSetNoder.yml\" sourcestartlinenumber=\"1\">Nodes a set of edges.\nTakes one or more sets of edges and constructs a\nnew set of edges consisting of all the split edges created by\nnoding the input edges together.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.LineBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.LineBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.LineBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.LineBuilder.yml\" sourcestartlinenumber=\"1\">Forms NTS LineStrings out of a the graph of <code>DirectedEdge</code>s\ncreated by an <code>OverlayOp</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.MaximalEdgeRing.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.MaximalEdgeRing.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.MaximalEdgeRing",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.MaximalEdgeRing.yml\" sourcestartlinenumber=\"1\">A ring of edges which may contain nodes of degree &gt; 2.\nA MaximalEdgeRing may represent two different spatial entities:\na single polygon possibly containing inversions (if the ring is oriented CW)\na single hole possibly containing exversions (if the ring is oriented CCW)\nIf the MaximalEdgeRing represents a polygon,\nthe interior of the polygon is strongly connected.\nThese are the form of rings used to define polygons under some spatial data models.\nHowever, under the OGC SFS model, MinimalEdgeRings are required.\nA MaximalEdgeRing can be converted to a list of MinimalEdgeRings using the\n<code>BuildMinimalRings()</code> method.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.MinimalEdgeRing.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.MinimalEdgeRing.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.MinimalEdgeRing",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.MinimalEdgeRing.yml\" sourcestartlinenumber=\"1\">A ring of edges with the property that no node\nhas degree greater than 2.  These are the form of rings required\nto represent polygons under the OGC SFS spatial data model.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.OverlayNodeFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.OverlayNodeFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.OverlayNodeFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.OverlayNodeFactory.yml\" sourcestartlinenumber=\"1\">Creates nodes for use in the <code>PlanarGraph</code>s constructed during\noverlay operations.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.OverlayOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.OverlayOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.OverlayOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.OverlayOp.yml\" sourcestartlinenumber=\"1\">Computes the geometric overlay of two <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s.  The overlay\ncan be used to determine any bool combination of the geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.PointBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.PointBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.PointBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.PointBuilder.yml\" sourcestartlinenumber=\"1\">Constructs <code>Point</code>s from the nodes of an overlay graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.PolygonBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.PolygonBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.PolygonBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.PolygonBuilder.yml\" sourcestartlinenumber=\"1\">Forms <code>Polygon</code>s out of a graph of {DirectedEdge}s.\nThe edges to use are marked as being in the result Area.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper.yml\" sourcestartlinenumber=\"1\">Snaps the vertices and segments of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\nto another Geometry's vertices.\nA snap distance tolerance is used to control where snapping is performed.\nSnapping one geometry to another can improve\nrobustness for overlay operations by eliminating\nnearly-coincident edges\n(which cause problems during noding and intersection calculation).\nIt can also be used to eliminate artifacts such as narrow slivers, spikes and gores.\nToo much snapping can result in invalid topology\nbeging created, so the number and location of snapped vertices\nis decided using heuristics to determine when it\nis safe to snap.\nThis can result in some potential snaps being omitted, however.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper.yml\" sourcestartlinenumber=\"1\">Snaps the vertices and segments of a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>\nto a set of target snap vertices.\nA snap distance tolerance is used to control where snapping is performed.</p>\n<p></p>The implementation handles empty geometry and empty snap vertex sets.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp.yml\" sourcestartlinenumber=\"1\">Performs an overlay operation using snapping and enhanced precision\nto improve the robustness of the result.\nThis class only uses snapping\nif an error is detected when running the standard JTS overlay code.\nErrors detected include thrown exceptions\n(in particular, <xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref>)\nand invalid overlay computations.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp.yml\" sourcestartlinenumber=\"1\">Performs an overlay operation using snapping and enhanced precision\nto improve the robustness of the result.\nThis class always uses snapping.\nThis is less performant than the standard JTS overlay code,\nand may even introduce errors which were not present in the original data.\nFor this reason, this class should only be used\nif the standard overlay code fails to produce a correct result.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Snap.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Snap.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Snap",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.SpatialFunction.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.SpatialFunction.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.SpatialFunction",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.SpatialFunction.yml\" sourcestartlinenumber=\"1\">The spatial functions supported by this class.\nThese operations implement various bool combinations of the resultants of the overlay.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator.yml\" sourcestartlinenumber=\"1\">Finds the most likely <xref href=\"NetTopologySuite.Geometries.Location\" data-throw-if-not-resolved=\"false\"></xref> of a point relative to\nthe polygonal components of a geometry, using a tolerance value.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator.yml\" sourcestartlinenumber=\"1\">Generates points offset by a given distance from both sides of the midpoint of all segments in a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator.yml\" sourcestartlinenumber=\"1\">Validates that the result of an overlay operation is geometrically correct within a determined tolerance.\nUses fuzzy point location to find points which are\ndefinitely in either the interior or exterior of the result\ngeometry, and compares these results with the expected ones.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.Validate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.Validate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay.Validate",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Overlay.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Overlay.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Overlay",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"5\">Contains classes that perform a topological overlay to compute boolean spatial functions.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"7\">The Overlay Algorithm is used in spatial analysis methods for computing set-theoretic operations (boolean combinations) of input <xref href=\"NetTopologySuite.Geometries.Geometry\">Geometries</xref>. The algorithm for computing the overlay uses the intersection operations supported by topology graphs. To compute an overlay it is necessary to explicitly compute the resultant graph formed by the computed intersections.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"9\">The algorithm to compute a set-theoretic spatial analysis method has the following steps:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"11\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"11\">Build topology graphs of the two input geometries. For each geometry all self-intersection nodes are computed and added to the graph.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"12\">Compute nodes for all intersections between edges and nodes of the graphs.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"13\">Compute the labeling for the computed nodes by merging the labels from the input graphs.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"14\">Compute new edges between the compute intersection nodes. Label the edges appropriately.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"15\">Build the resultant graph from the new nodes and edges.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"16\">Compute the labeling for isolated components of the graph. Add the isolated components to the resultant graph.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"17\">Compute the result of the boolean combination by selecting the node and edges with the appropriate labels. Polygonize areas and sew linear geometries together.</li>\n</ul>\n<h1 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"19\">Package Specification</h1>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"20\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"20\">Java Topology Suite Technical Specifications</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"21\"><a href=\"http://www.opengis.org/techno/specs.htm\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Overlay.md\" sourcestartlinenumber=\"21\">OpenGIS Simple Features Specification for SQL</a></li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.CoverageUnion.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.CoverageUnion.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.CoverageUnion",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.CoverageUnion.yml\" sourcestartlinenumber=\"1\">Unions a valid coverage of polygons or lines\nin an efficient way.</p>\n<p></p>\nA <b>polygonal coverage</b> is a collection of <xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref>s\nwhich satisfy the following conditions:\n<ol><li><span class=\"term\">Vector-clean</span>Line segments within the collection\nmust either be identical or intersect only at endpoints.</li><li><span class=\"term\">Non-overlapping</span>No two polygons\nmay overlap. Equivalently, polygons must be interior-disjoint.</li></ol>\n<p></p>\nA <b>linear coverage</b> is a collection of <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref>s\nwhich satisfies the <b>Vector-clean</b> condition.\nNote that this does not require the LineStrings to be fully noded\n- i.e. they may contain coincident linework.\nCoincident line segments are dissolved by the union.\nCurrently linear output is not merged (this may be added in a future release.)\n<p></p>\nNo checking is done to determine whether the input is a valid coverage.\nThis is because coverage validation involves segment intersection detection,\nwhich is much more expensive than the union phase.\nIf the input is not a valid coverage\nthen in some cases this will be detected during processing \nand a <xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.\nOtherwise, the computation will produce output, but it will be invalid.\n<p></p>\nUnioning a valid coverage implies that no new vertices are created.\nThis means that a precision model does not need to be specified.\nThe precision of the vertices in the output geometry is not changed.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.LineLimiter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.LineLimiter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.LineLimiter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.LineLimiter.yml\" sourcestartlinenumber=\"1\">Limits the segments in a list of segments\nto those which intersect an envelope.\nThis creates zero or more sections of the input segment sequences,\ncontaining only line segments which intersect the limit envelope.\nSegments are not clipped, since that can move\nline segments enough to alter topology,\nand it happens in the overlay in any case.\nThis can substantially reduce the number of vertices which need to be\nprocessed during overlay.</p>\n<p></p>\nThis optimization is only applicable to Line geometries,\nsince it does not maintain the closed topology of rings.\nPolygonal geometries are optimized using the <xref href=\"NetTopologySuite.Operation.OverlayNG.RingClipper\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.OverlayNG.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.OverlayNG.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.OverlayNG",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.OverlayNG.yml\" sourcestartlinenumber=\"1\">Computes the geometric overlay of two <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s,\nusing an explicit precision model to allow robust computation.</p>\n<p></p>\nThe overlay can be used to determine any of the\nfollowing set-theoretic operations (boolean combinations) of the geometries:\n<ul><li><span class=\"term\"><xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection\" data-throw-if-not-resolved=\"false\"></xref></span>all points which lie in both geometries</li><li><span class=\"term\"><xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.Union\" data-throw-if-not-resolved=\"false\"></xref></span>all points which lie in at least one geometry</li><li><span class=\"term\"><xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.Difference\" data-throw-if-not-resolved=\"false\"></xref></span>all points which lie in the first geometry but not the second</li><li><span class=\"term\"><xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference\" data-throw-if-not-resolved=\"false\"></xref></span>all points which lie in one geometry but not both</li></ul>\nInput geometries may have different dimension.\nInput collections must be homogeneous (all elements must have the same dimension).\nInputs may be <b>simple</b> <xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref>s.\nA GeometryCollection is simple if it can be flattened into a valid Multi-geometry;\ni.e.it is homogeneous and does not contain any overlapping Polygons.\n<p></p>\nThe precision model used for the computation can be supplied\nindependent of the precision model of the input geometry.\nThe main use for this is to allow using a fixed precision\nfor geometry with a floating precision model.\nThis does two things: ensures robust computation;\nand forces the output to be validly rounded to the precision model.\n<p></p>\nFor fixed precision models noding is performed using a <xref href=\"NetTopologySuite.Noding.Snapround.SnapRoundingNoder\" data-throw-if-not-resolved=\"false\"></xref>.\nThis provides robust computation(as long as precision is limited to\naround 13 decimal digits).\n<p></p>\nFor floating precision an <xref href=\"NetTopologySuite.Noding.MCIndexNoder\" data-throw-if-not-resolved=\"false\"></xref> is used.\nThis is not fully robust, so can sometimes result in \n<xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref>s being thrown.\nFor robust full-precision overlay see <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNGRobust\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nA custom <xref href=\"NetTopologySuite.Noding.INoder\" data-throw-if-not-resolved=\"false\"></xref> can be supplied.\nThis allows using a more performant noding strategy in specific cases,\nfor instance in <xref href=\"NetTopologySuite.Operation.OverlayNG.CoverageUnion\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\n<b>Note:</b> If a <xref href=\"NetTopologySuite.Noding.Snap.SnappingNoder\" data-throw-if-not-resolved=\"false\"></xref> is used\nit is best to specify a fairly small snap tolerance,\nsince the intersection clipping optimization can\ninteract with the snapping to alter the result.\n<p></p>\nOptionally the overlay computation can process using strict mode\n(via <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNG.StrictMode\" data-throw-if-not-resolved=\"false\"></xref> = <code>true</code>).\nIn strict mode result semantics are:\n<ul><li>Lines and Points resulting from topology collapses are not included in the result</li><li>Result geometry is homogeneous\nfor the <xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.Intersection\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.Difference\" data-throw-if-not-resolved=\"false\"></xref> operations.</li><li>Result geometry is homogeneous\nfor the <xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.Union\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NetTopologySuite.Operation.Overlay.SpatialFunction.SymDifference\" data-throw-if-not-resolved=\"false\"></xref> operations\nif the inputs have the same dimension</li></ul>\nStrict mode has the following benefits:\n<ul><li>Results are simpler</li><li>Overlay operations are easily chainable\nwithout needing to remove lower-dimension elements</li></ul>\nThe original JTS overlay semantics corresponds to non-strict mode.\n<p></p>\nIf a robustness error occurs, a <xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.\nThese are usually caused by numerical rounding causing the noding output\nto not be fully noded.\nFor robust computation with full-precision <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNGRobust\" data-throw-if-not-resolved=\"false\"></xref>\ncan be used.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.OverlayNGRobust",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.yml\" sourcestartlinenumber=\"1\">Performs an overlay operation using <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNG\" data-throw-if-not-resolved=\"false\"></xref>,\nincreasing robustness by using a series of\nincreasingly robust (but slower) noding strategies.</p>\n<p></p>\nThe noding strategies used are:\n<ol><li>A simple fast noder using <xref href=\"NetTopologySuite.Geometries.PrecisionModels.Floating\" data-throw-if-not-resolved=\"false\"></xref> precision</li><li>A <xref href=\"NetTopologySuite.Noding.Snap.SnappingNoder\" data-throw-if-not-resolved=\"false\"></xref> using an automatically-determined snap tolerance</li><li>First snapping each geometry to itself, and then overlaying them wih a <xref href=\"NetTopologySuite.Noding.Snap.SnappingNoder\" data-throw-if-not-resolved=\"false\"></xref></li><li>The above two strategies are repeated with increasing snap tolerance, up to a limit</li><li>Finally a <xref href=\"NetTopologySuite.Noding.Snapround.SnapRoundingNoder\" data-throw-if-not-resolved=\"false\"></xref> is used with a automatically-determined scale factor.</li></ol>\nIf all of the above heuristics fail to compute a valid overlay,\nthe original <xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.\nIn practice this should be extremely unlikely to occur.\n<p></p>\nThis algorithm relies on each overlay operation execution\nthrowing a <xref href=\"NetTopologySuite.Geometries.TopologyException\" data-throw-if-not-resolved=\"false\"></xref> if it is unable\nto compute the overlay correctly.\nGenerally this occurs because the noding phase does\nnot produce a valid noding.\nThis requires the use of a <xref href=\"NetTopologySuite.Noding.ValidatingNoder\" data-throw-if-not-resolved=\"false\"></xref>\nin order to check the results of using a floating noder.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.PrecisionReducer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.PrecisionReducer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.PrecisionReducer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.PrecisionReducer.yml\" sourcestartlinenumber=\"1\">Functions to reduce the precision of a geometry\nby rounding it to a given precision model.</p>\n<p></p>\nThis class handles only polygonal and linear inputs.\nFor full functionality <xref href=\"NetTopologySuite.Precision.GeometryPrecisionReducer\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.PrecisionUtility.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.PrecisionUtility.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.PrecisionUtility",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.PrecisionUtility.yml\" sourcestartlinenumber=\"1\">Functions for computing precision model scale factors\nthat ensure robust geometry operations.\nIn particular, these can be used to\nautomatically determine appropriate scale factors for operations\nusing limited-precision noding (such as <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNG\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p></p>\nWARNING: the <code>inherentScale</code> and <code>robustScale</code> \nfunctions can be very slow, due to the method used to determine\nnumber of decimal places of a number.\nThese are not recommended for production use.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.RingClipper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.RingClipper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.RingClipper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.RingClipper.yml\" sourcestartlinenumber=\"1\">Clips a ring of points to an rectangle.\nUses a variant of Cohen-Sutherland clipping.</p>\n<p></p>\nIn general the output is not topologically valid.\nIn particular, the output may contain coincident non-noded line segments\nalong the clip rectangle sides.\nHowever, the output is sufficiently well-structured\nthat it can be used as input to the <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNG\" data-throw-if-not-resolved=\"false\"></xref> algorithm\n(which is able to process coincident linework due\nto the need to handle topology collapse under precision reduction).\n<p></p>\nBecause of the likelihood of creating\nextraneous line segments along the clipping rectangle sides,\nthis class is not suitable for clipping linestrings.\n<p></p>\nThe clipping envelope should be generated using <xref href=\"NetTopologySuite.Operation.OverlayNG.RobustClipEnvelopeComputer\" data-throw-if-not-resolved=\"false\"></xref>,\nto ensure that intersecting line segments are not perturbed\nby clipping.\nThis is required to ensure that the overlay of the\nclipped geometry is robust and correct (i.e. the same as\nif clipping was not used).\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.UnaryUnionNG.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.UnaryUnionNG.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG.UnaryUnionNG",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.OverlayNG.UnaryUnionNG.yml\" sourcestartlinenumber=\"1\">Unions a collection of geometries in an\nefficient way, using <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNG\" data-throw-if-not-resolved=\"false\"></xref>\nto ensure robust computation.</p>\n<p></p>\nThis class is most useful for performing UnaryUnion using\na fixed-precision model.<br>\nFor unary union using floating precision,\n<xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNGRobust.Union(NetTopologySuite.Geometries.Geometry)\" data-throw-if-not-resolved=\"false\"></xref> should be used.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.OverlayNG.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.OverlayNG.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.OverlayNG",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"5\">Contains classes that perform vector overlay to compute boolean set-theoretic spatial functions.\nOverlay operations are used in spatial analysis for computing set-theoretic operations (boolean combinations) of input <xref href=\"NetTopologySuite.Geometries.Geometry\">Geometry</xref> s.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"8\">The <xref href=\"NetTopologySuite.Operation.OverlayNG.OverlayNG\">OverlayNG</xref> class provides the standard Simple Features\nboolean set-theoretic overlay operations.<br>\nThese are:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"11\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"11\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"11\">Intersection</strong> - all points which lie in both geometries</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"12\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"12\">Union</strong> - all points which lie in at least one geometry</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"13\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"13\">Difference</strong> - all points which lie in the first geometry but not the second</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"14\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"14\">Symmetric Difference</strong> - all points which lie in one geometry but not both</li>\n</ul>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"16\">These operations are supported for all combinations of the basic geometry types and their homogeneous collections.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"18\">Additional operations include:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"20\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"20\"><xref href=\"NetTopologySuite.Operation.Union.UnaryUnionOp\">UnaryUnion</xref> unions collections of geometries in an efficient way</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"21\"><xref href=\"NetTopologySuite.Operation.OverlayNG.CoverageUnion\">CoverageUnion</xref> provides enhanced performance for unioning valid polygonal and lineal coverages</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"22\"><xref href=\"NetTopologySuite.Operation.OverlayNG.PrecisionReducer\">PrecisionReducer</xref> allows reducing the precision of a geometry in a topologically-valid way</li>\n</ul>\n<h2 id=\"semantics\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"24\">Semantics</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"25\">The requirements for overlay input are:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"26\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"26\">Input geometries may have different dimension.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"27\">Collections must be homogeneous<br>\n(all elements must have the same dimension).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"29\">In general, inputs must be valid geometries.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"30\">However, polygonal inputs may contain the following two kinds of &quot;mild&quot; invalid topology:\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"31\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"31\">rings which self-touch at discrete points (sometimes called inverted shells and exverted holes).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"32\">rings which touch along line segments (i.e. topology collapse).</li>\n</ul>\n</li>\n</ul>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"34\">The semantics of overlay output are:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"35\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"35\">Results are always valid geometries.<br>\nIn particular, result <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"36\">MultiPolygon</code>s are valid.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"37\">Repeated vertices are removed</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"38\">Linear results include all nodes (endpoints) present in the input.\nIn some cases more nodes will be present.\n(If merged lines are required see <xref href=\"NetTopologySuite.Operation.Linemerge.LineMerger\">LineMerger</xref>.)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"41\">Polygon edges which undergo topology collapse to lines\n(due to rounding or snapping) are included in the result.\nThis means that all operations may produce a heterogeneous result.\nUsually this only occurs when using a fixed-precision model,\nbut it can happen due to snapping performed to improve robustness.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"46\">The <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"46\">intersection</code> operation result includes all components of the\nintersection for geometries which intersect in components of the same and/or\nlower dimension.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"49\">The <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"49\">difference</code> operation produces a homogeneous result if no topology\ncollapses are present.<br>\nIn this case the result dimension is equal to that of the left-hand operand.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"52\">The <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"52\">union</code> and <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"52\">symmetric difference</code> operations\nmay produce heterogeneous result if the inputs are of mixed dimension.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"54\">Homogeneous results are output as <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"54\">Multi</code> geometries.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"55\">Heterogeneous results are output as a <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"55\">GeometryCollection</code>\ncontaining a set of atomic geometries.<br>\n(This provides backwards compatibility\nwith the original NTS overlay implementation.\nHowever, it loses the information that the polygonal results\nhave valid <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"60\">MultiPolygon</code> topology.)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"61\">Empty results are atomic <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"61\">EMPTY</code> geometries of dimension appropriate\nto the operation.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"63\">As far as possible, results preserve the order and direction of the inputs.\nFor instance, a MultiLineString intersection with a Polygon\nwill have resultants which are in the same order and have the same direction\nas the input lines (assuming the input lines are disjoint).\nIf an input line is split into two or more parts,\nthey are ordered in the direction of occurence along their parent line.</li>\n</ul>\n<h2 id=\"features\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"70\">Features</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"71\">Functionality</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"72\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"72\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"72\">Precision Model</strong> - operations are performed using a defined precision model (finite or floating)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"73\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"73\">Robust Computation</strong> - provides fully robust computation when an appropriate noder is used</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"74\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"74\">Performance optimizations</strong> - including:\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"75\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"75\">Short-circuiting for disjoint input envelopes</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"76\">Reduction of input segment count via clipping / limiting to overlap envelope</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"77\">Optimizations can be disabled if required (e.g. for testing or performance evaluation)</li>\n</ul>\n</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"78\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"78\">Pluggable Noding</strong> - allows using different noders to change characteristics of performance and accuracy</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"79\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"79\">Precision Reduction</strong> - in a topologically correct way. Implemented by unioning a single input with an empty geometry</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"80\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"80\">[Topology Correction / Conversion]</strong> - handles certain kinds\nof polygonal inputs which are invalid</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"82\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"82\">Fast Coverage Union</strong> - of valid polygonal and linear coverages</li>\n</ul>\n<h2 id=\"pluggable-noding\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"84\">Pluggable Noding</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"85\">The noding phase of overlay uses a <xref href=\"NetTopologySuite.Noding.INoder\">INoder</xref> subclass. This is determine automatically based on the precision model of the input. Or it can be provided explicity, which allows changing characteristics of performance and robustness. Examples of relevant noders include:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"86\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"86\"><xref href=\"NetTopologySuite.Noding.MCIndexNoder\">MCIndexNoder</xref> - a fast full-precision noder, which however may not produce\na valid noding in some situations. Should be combined with a <xref href=\"NetTopologySuite.Noding.ValidatingNoder\">ValidatingNoder</xref> wrapper to detect\nnoding failures.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"89\"><xref href=\"NetTopologySuite.Noding.Snap.SnappingNoder\">SnappingNoder</xref> - a robust full-precision noder</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"90\"><xref href=\"NetTopologySuite.Noding.Snapround.SnapRoundingNoder\">SnapRoundingNoder</xref> - a noder which enforces a supplied fixed precision model\nby snapping vertices and intersections to a grid</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"92\"><xref href=\"NetTopologySuite.Noding.ValidatingNoder\">ValidatingNoder</xref> - a wrapper which can be used to verify the noding prior to topology building</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"93\"><xref href=\"NetTopologySuite.Operation.OverlayNG.SegmentExtractingNoder\">SegmentExtractingNoder</xref> - requires node-clean input, and provides very fast noding</li>\n</ul>\n<h2 id=\"topology-correction--conversion\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"95\">Topology Correction / Conversion</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"96\">As noted above, the overlay process\ncan handle polygonal inputs which are invalid according to the OGC topology model\nin certain limited ways.\nThese invalid conditions are:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"100\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"100\">rings which self-touch at discrete points (sometimes called inverted shells and exverted holes).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"101\">rings which touch along line segments (i.e. topology collapse).</li>\n</ul>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"103\">These invalidities are corrected during the overlay process.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"105\">Some of these invalidities are considered as valid in other geometry models.\nBy peforming a self-overlay these inputs can be converted\ninto the JTS OGC topological model.</p>\n<h2 id=\"codebase\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"109\">Codebase</h2>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"110\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"110\">Defines a simple, full-featured topology model, with clear semantics.\nThe topology model incorporates handling topology collapse, which is\nessential for snapping and fixed-precision noding.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"113\">Uses a simple topology graph data structure (based on the winged edge pattern).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"114\">Uses a simpler topology graph data structure (based on winged edge pattern).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"115\">Decouples noding and topology-build phases. This makes the code clearer, and makes it possible to allow supplying alternate implementations and semantics for each phase.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"116\">All optimizations are implemented internally, so that clients do not have to add checks such as envelope overlap&lt;./li&gt;</li>\n</ul>\n<h2 id=\"algorithm\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"118\">Algorithm</h2>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"119\">For non-point inputs the overlay algorithm is:</p>\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"120\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"120\">Check for empty input geometries, and return a result appropriate for the specified operation</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"121\">Extract linework and points from input geometries, with topology location information</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"122\">(If optimization enabled) Apply overlap envelope optimizations:\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"123\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"123\">For Intersection, check if the input envelopes are disjoint (using an envelope expansion adjustment to account for the precision grid).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"124\">For Intersection and Difference, clip or limit the linework of the input geometries to the overlap envelope.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"125\">If the optimized linework is empty, return an empty result of appropriate type.</li>\n</ol>\n</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"126\">Node the linework. For full robustness snap-rounding noding is used. Other kinds of noder can be used as well (for instance, the full-precision noding algorithm as the original overlay code).</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"127\">Merge noded edges. Coincident edges from the two input geometries are merged, along with their topological labelling. Topology collapses are detected in this step, and are flagged in the labelling so they can be handled appropriately duing result polygon extraction</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"128\">Build a fully-labelled topology graph. This includes:\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"129\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"129\">Create a graph structure on the noded, merged edges</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"130\">Propagate topology locations around nodes in the graph</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"131\">Label edges that have incomplete topology locations. These occur when edges from an input geometry are isolated (disjoint from the edges of the other geometry in the graph).</li>\n</ol>\n</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"132\">If result is empty return an empty geometry of appropriate type</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"133\">Generate the result geometry from the labelled graph:\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"134\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"134\">Build result polygons\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"135\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"135\">Mark edges which should be included in the result areas</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"136\">Link maximal rings together</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"137\">Convert maximal rings to minimal (valid) rings</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"138\">Determine nesting of holes</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"139\">Construct result polygons</li>\n</ol>\n</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"140\">Build result linework\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"141\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"141\">Mark edges to be included in the result lines</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"142\">Construct node-to-node linework</li>\n</ol>\n</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"143\">Build result points\n<ol sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"144\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"144\">For intersection only, output point occur where the input touch at single points</li>\n</ol>\n</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"145\">Collect result elements into the result geometry</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"147\">Package Specification</h2>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"148\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.OverlayNG.md\" sourcestartlinenumber=\"148\">OpenGIS Simple Features Specification for SQL</li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeAreaComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeAreaComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeAreaComparator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeAreaComparator.yml\" sourcestartlinenumber=\"1\">Compares EdgeRings based on the area of their envelopes.\nSmaller envelopes sort before bigger ones.\nThis effectively sorts EdgeRings in order of containment.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeComparator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeComparator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeComparator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.EdgeRing.EnvelopeComparator.yml\" sourcestartlinenumber=\"1\">Compares EdgeRings based on their envelope,\nusing the standard lexicographic ordering.\nThis ordering is sufficient to make edge ring sorting deterministic.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.EdgeRing.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.EdgeRing.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.EdgeRing",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.EdgeRing.yml\" sourcestartlinenumber=\"1\">Represents a ring of <xref href=\"NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge\" data-throw-if-not-resolved=\"false\"></xref>s which form\na ring of a polygon.  The ring may be either an outer shell or a hole.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.HoleAssigner.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.HoleAssigner.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.HoleAssigner",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.HoleAssigner.yml\" sourcestartlinenumber=\"1\">Assigns hole rings to shell rings\nduring polygonization.\nUses spatial indexing to improve performance\nof shell lookup.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge.yml\" sourcestartlinenumber=\"1\">A <code>DirectedEdge</code> of a <code>PolygonizeGraph</code>, which represents\nan edge of a polygon formed by the graph.\nMay be logically deleted from the graph by setting the <code>marked</code> flag.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.PolygonizeEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.PolygonizeEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.PolygonizeEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.PolygonizeEdge.yml\" sourcestartlinenumber=\"1\">An edge of a polygonization graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.PolygonizeGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.PolygonizeGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.PolygonizeGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.PolygonizeGraph.yml\" sourcestartlinenumber=\"1\">Represents a planar graph of edges that can be used to compute a\npolygonization, and implements the algorithms to compute the\n<xref href=\"NetTopologySuite.Operation.Polygonize.EdgeRing\" data-throw-if-not-resolved=\"false\"></xref>s formed by the graph.\nThe marked flag on DirectedEdges is used to indicate that a directed edge\nhas be logically deleted from the graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.Polygonizer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.Polygonizer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize.Polygonizer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Polygonize.Polygonizer.yml\" sourcestartlinenumber=\"1\">Polygonizes a set of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s which contain linework that\nrepresents the edges of a planar graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Polygonize.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Polygonize.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Polygonize",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Polygonize.md\" sourcestartlinenumber=\"5\">Contains classes to implement a polygonization algorithm. This package can be used to create polygons from fully noded linework.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Predicate.RectangleContains.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Predicate.RectangleContains.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Predicate.RectangleContains",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Predicate.RectangleContains.yml\" sourcestartlinenumber=\"1\">Optimized implementation of spatial predicate &quot;contains&quot;\nfor cases where the first <code>Geometry</code> is a rectangle.\nAs a further optimization,\nthis class can be used directly to test many geometries against a single rectangle.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Predicate.RectangleIntersects.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Predicate.RectangleIntersects.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Predicate.RectangleIntersects",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Predicate.RectangleIntersects.yml\" sourcestartlinenumber=\"1\">I\nImplementation of the <tt>Intersects</tt> spatial predicate\noptimized for the case where one <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> is a rectangle.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Predicate.SegmentIntersectionTester.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Predicate.SegmentIntersectionTester.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Predicate.SegmentIntersectionTester",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Predicate.SegmentIntersectionTester.yml\" sourcestartlinenumber=\"1\">Tests if any line segments in two sets of <xref href=\"NetTopologySuite.Geometries.CoordinateSequences\" data-throw-if-not-resolved=\"false\"></xref> intersect.\nOptimized for use when at least one input is of small size.\nShort-circuited to return as soon an intersection is found.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Predicate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Predicate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Predicate",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.EdgeEndBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.EdgeEndBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.EdgeEndBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.EdgeEndBuilder.yml\" sourcestartlinenumber=\"1\">An EdgeEndBuilder creates EdgeEnds for all the &quot;split edges&quot;\ncreated by the intersections determined for an Edge.\nComputes the <code>EdgeEnd</code>s which arise from a noded <code>Edge</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.EdgeEndBundle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.EdgeEndBundle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.EdgeEndBundle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.EdgeEndBundle.yml\" sourcestartlinenumber=\"1\">A collection of EdgeStubs which obey the following invariant:\nThey originate at the same node and have the same direction.\nContains all <code>EdgeEnd</code>s which start at the same point and are parallel.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.EdgeEndBundleStar.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.EdgeEndBundleStar.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.EdgeEndBundleStar",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.EdgeEndBundleStar.yml\" sourcestartlinenumber=\"1\">An ordered list of <code>EdgeEndBundle</code>s around a <code>RelateNode</code>.\nThey are maintained in CCW order (starting with the positive x-axis) around the node\nfor efficient lookup and topology building.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.RelateComputer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.RelateComputer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.RelateComputer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.RelateComputer.yml\" sourcestartlinenumber=\"1\">Computes the topological relationship between two Geometries.\nRelateComputer does not need to build a complete graph structure to compute\nthe IntersectionMatrix.  The relationship between the geometries can\nbe computed by simply examining the labelling of edges incident on each node.\nRelateComputer does not currently support arbitrary GeometryCollections.\nThis is because GeometryCollections can contain overlapping Polygons.\nIn order to correct compute relate on overlapping Polygons, they\nwould first need to be noded and merged (if not explicitly, at least\nimplicitly).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.RelateNode.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.RelateNode.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.RelateNode",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.RelateNode.yml\" sourcestartlinenumber=\"1\">A RelateNode is a Node that maintains a list of EdgeStubs\nfor the edges that are incident on it.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.RelateNodeFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.RelateNodeFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.RelateNodeFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.RelateNodeFactory.yml\" sourcestartlinenumber=\"1\">Used by the <code>NodeMap</code> in a <code>RelateNodeGraph</code> to create <code>RelateNode</code>s.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.RelateNodeGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.RelateNodeGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.RelateNodeGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.RelateNodeGraph.yml\" sourcestartlinenumber=\"1\">Implements the simple graph of Nodes and EdgeEnd which is all that is\nrequired to determine topological relationships between Geometries.\nAlso supports building a topological graph of a single Geometry, to\nallow verification of valid topology.\nIt is not necessary to create a fully linked\nPlanarGraph to determine relationships, since it is sufficient\nto know how the Geometries interact locally around the nodes.\nIn fact, this is not even feasible, since it is not possible to compute\nexact intersection points, and hence the topology around those nodes\ncannot be computed robustly.\nThe only Nodes that are created are for improper intersections;\nthat is, nodes which occur at existing vertices of the Geometries.\nProper intersections (e.g. ones which occur between the interior of line segments)\nhave their topology determined implicitly, without creating a Node object\nto represent them.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.RelateOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.RelateOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate.RelateOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Relate.RelateOp.yml\" sourcestartlinenumber=\"1\">Implements the SFS <code>relate()</code>  generalized spatial predicate on two <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s.\n<br>\nThe class supports specifying a custom <xref href=\"NetTopologySuite.Algorithm.IBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref>\nto be used during the relate computation.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Relate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Relate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Relate",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"5\">Contains classes to implement the computation of the spatial relationships of Geometrys.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"7\">The relate algorithm computes the IntersectionMatrix describing the relationship of two Geometrys. The algorithm for computing relate uses the intersection operations supported by topology graphs. Although the relate result depends on the resultant graph formed by the computed intersections, there is no need to explicitly compute the entire graph. It is sufficient to compute the local structure of the graph at each intersection node.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"9\">The algorithm to compute relate has the following steps:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"10\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"10\">Build topology graphs of the two input geometries. For each geometry all self-intersection nodes are computed and added to the graph.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"11\">Compute nodes for all intersections between edges and nodes of the graphs.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"12\">Compute the labeling for the computed nodes by merging the labels from the input graphs.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"13\">Compute the labeling for isolated components of the graph (see below)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"14\">Compute the IntersectionMatrix from the labels on the nodes and edges.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"15\">Labeling isolated components</li>\n</ul>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"17\">Isolated components are components (edges or nodes) of an input Geometry which do not contain any intersections with the other input Geometry. The topological relationship of these components to the other input Geometry must be computed in order to determine the complete labeling of the component. This can be done by testing whether the component lies in the interior or exterior of the other Geometry. If the other Geometry is 1-dimensional, the isolated component must lie in the exterior (since otherwise it would have an intersection with an edge of the Geometry). If the other Geometry is 2-dimensional, a Point-In-Polygon test can be used to determine whether the isolated component is in the interior or exterior.</p>\n<h1 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"19\">Package Specification</h1>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"20\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"20\">Java Topology Suite Technical Specifications</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"21\"><a href=\"http://www.opengis.org/techno/specs.htm\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Relate.md\" sourcestartlinenumber=\"21\">OpenGIS Simple Features Specification for SQL</a></li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.RelateNG.IntersectionMatrixPattern.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.RelateNG.IntersectionMatrixPattern.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.RelateNG.IntersectionMatrixPattern",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.IntersectionMatrixPattern.yml\" sourcestartlinenumber=\"1\">String constants for DE-9IM matrix patterns for topological relationships.\nThese can be used with <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG.Evaluate(NetTopologySuite.Geometries.Geometry%2cSystem.String)\" data-throw-if-not-resolved=\"false\"></xref>\nand <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG.Relate(NetTopologySuite.Geometries.Geometry%2cNetTopologySuite.Geometries.Geometry%2cSystem.String)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\n<h3> DE - 9IM Pattern Matching </h3>\nMatrix patterns are specified as a 9 - character string\ncontaining the pattern symbols for the DE-9IM 3x3 matrix entries,\nlisted row - wise.\nThe pattern symbols are:\n<table><thead><tr><th class=\"term\">Code</th><th class=\"description\">Description</th></tr></thead><tbody><tr><td class=\"term\">0</td><td class=\"description\">topological interaction has dimension 0</td></tr><tr><td class=\"term\">1</td><td class=\"description\">topological interaction has dimension 1</td></tr><tr><td class=\"term\">2</td><td class=\"description\">topological interaction has dimension 2</td></tr><tr><td class=\"term\">F</td><td class=\"description\">no topological interaction</td></tr><tr><td class=\"term\">T</td><td class=\"description\">topological interaction of any dimension</td></tr><tr><td class=\"term\">*</td><td class=\"description\">any topological interaction is allowed, including none</td></tr></tbody></table>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.RelateNG.RelateNG.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.RelateNG.RelateNG.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.RelateNG.RelateNG",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.RelateNG.yml\" sourcestartlinenumber=\"1\">Computes the value of topological predicates between two geometries based on the\n<a href=\"https://en.wikipedia.org/wiki/DE-9IM\"> Dimensionally - Extended 9-Intersection Model</a>(DE-9IM).\nStandard and custom topological predicates are provided by <xref href=\"NetTopologySuite.Operation.RelateNG.RelatePredicate\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nThe RelateNG algorithm has the following capabilities:\n<ol><li>Efficient short-circuited evaluation of topological predicates\n(including matching custom DE-9IM matrix patterns)</li><li>Optimized repeated evaluation of predicates against a single geometry\nvia cached spatial indexes (AKA \"prepared mode\")</li><li>Robust computation (only point-local topology is required,\nso invalid geometry topology does not cause failures)</li><li><xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref> inputs containing mixed types and overlapping polygons\nare supported, using <i>union semantics</i>.</li><li>Zero - length LineStrings are treated as being topologically identical to Points.</li><li>Support for <xref href=\"NetTopologySuite.Algorithm.IBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref>s.</li></ol>\n<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.RelateNG.yml\" sourcestartlinenumber=\"12\">See <xref href=\"NetTopologySuite.Operation.RelateNG.IntersectionMatrixPattern\" data-throw-if-not-resolved=\"false\"></xref>\nfor a description of DE - 9IM patterns.</p>\n<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.RelateNG.yml\" sourcestartlinenumber=\"15\">If not specified, the standard <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref> is used.\nRelateNG operates in 2D only; it ignores any Z ordinates.</p>\n<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.RelateNG.yml\" sourcestartlinenumber=\"18\">This implementation replaces <xref href=\"NetTopologySuite.Operation.Relate.RelateOp\" data-throw-if-not-resolved=\"false\"></xref>\nand <xref href=\"NetTopologySuite.Geometries.Prepared.IPreparedGeometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<h3>FUTURE WORK</h3>\n<ul><li>Support for a distance tolerance to provide \"approximate\" predicate evaluation</li></ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.RelateNG.RelatePredicate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.RelateNG.RelatePredicate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.RelateNG.RelatePredicate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.RelatePredicate.yml\" sourcestartlinenumber=\"1\">Creates predicate instances for evaluating OGC-standard named topological relationships.\nPredicates can be evaluated for geometries using <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.RelateNG.TopologyPredicate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.RelateNG.TopologyPredicate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.RelateNG.TopologyPredicate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.TopologyPredicate.yml\" sourcestartlinenumber=\"1\">The API for strategy classes implementing\nspatial predicates based on the DE-9IM topology model.\nPredicate values for specific geometry pairs can be evaluated by <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.RelateNG.TopologyPredicateTracer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.RelateNG.TopologyPredicateTracer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.RelateNG.TopologyPredicateTracer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.RelateNG.TopologyPredicateTracer.yml\" sourcestartlinenumber=\"1\">Traces the evaluation of a <xref href=\"NetTopologySuite.Operation.RelateNG.TopologyPredicate\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.RelateNG.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.RelateNG.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.RelateNG",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"5\">Provides classes to implement the RelateNG algorithm\ncomputes topological relationships of <xref href=\"NetTopologySuite.Geometries.Geometry\">Geometry</xref>s.<br>\nTopology is evaluated based on the\n<a href=\"https://en.wikipedia.org/wiki/DE-9IM\">Dimensionally-Extended 9-Intersection Model</a> (DE-9IM).<br>\nThe <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG\">RelateNG</xref> class supports computing the value of boolean topological predicates\nStandard OGC named predicates are provided by the <xref href=\"NetTopologySuite.Operation.RelateNG.RelatePredicate\">RelatePredicate</xref> functions.\nCustom relationships can be specified via testing against DE-9IM matrix patterns\n(see <xref href=\"NetTopologySuite.Operation.RelateNG.IntersectionMatrixPattern\">IntersectionMatrixPattern</xref> for examples).\nThe full DE-9IM <xref href=\"NetTopologySuite.Operation.RelateNG.IntersectionMatrix\">IntersectionMatrix</xref> can also be computed.</p>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"15\">The algorithm has the following capabilities:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"16\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"16\">Efficient short-circuited evaluation of topological predicates\n(including matching custom DE-9IM patterns)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"18\">Optimized repeated evaluation of predicates against a single geometry\nvia cached spatial indexes (AKA &quot;prepared mode&quot;)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"20\">Robust computation (since only point-local topology is required,\nso that invalid geometry topology cannot cause failures)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"22\">Support for mixed-type and overlapping {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"22\"></xref> GeometryCollection} inputs\n(using <em sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"23\">union semantics</em>)</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"24\">Support for <xref href=\"NetTopologySuite.Algorithm.IBoundaryNodeRule\">IBoundaryNodeRule</xref></li>\n</ul>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"26\">RelateNG operates in 2D only; it ignores any Z ordinates.</p>\n<h3 id=\"optimized-short-circuited-evaluation\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"28\">Optimized Short-Circuited Evaluation</h3>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"29\">The RelateNG algorithm uses strategies to optimize the evaluation of\ntopological predicates, including matching DE-9IM matrix patterns.\nThese include fast tests of dimensions and envelopes, and short-circuited evaluation\nonce the predicate value is known\n(either satisfied or failed) based on the value of matrix entries.\nNamed predicates used explicit strategy code.\nDE-9IM matrix pattern matching are short-circuited where possible\nbased on analysis of the pattern matrix entries.\nSpatial indexes are used to optimize topological computations\n(such as locating points in geometry elements,\nand analyzing the topological relationship between geometry edges).</p>\n<h3 id=\"execution-modes\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"41\">Execution Modes</h3>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"42\">RelateNG provides two execution modes for evaluating predicates:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"43\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"43\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"43\">Single-shot</strong> mode evaluates a predicate for a single case of two geometries.\nIt is provided by the <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG\">RelateNG</xref> static functions which take two input geometries.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"45\"><strong sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"45\">Prepared</strong> mode optimizes repeated evaluation of predicates\nagainst a fixed geometry.\nIt is used by creating an instance of <xref href=\"NetTopologySuite.Operation.RelateNG.RelateNG\">RelateNG</xref>\non the required geometry with the <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"48\">Prepare</code> functions,\nand then using the <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"49\">Evaluate</code> methods.\nIt provides much faster performance for repeated operations against a single geometry.</li>\n</ul>\n<h3 id=\"robustness\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"52\">Robustness</h3>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"53\">RelateNG provides robust evaluation of topological relationships,\nup to the precision of double-precision computation.\nIt computes topological relationships in the locality of discrete points,\nwithout constructing a full topology graph of the inputs.\nThis means that invalid input geometries or numerical round-off do not cause exceptions\n(although they may return incorrect answers).\nHowever, it is necessary to node some inputs together (in particular, linear elements)\nin order to provide consistent evaluation of the topological structure.</p>\n<h3 id=\"geometrycollection-handling\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"62\">GeometryCollection Handling</h3>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"63\"><xref href=\"NetTopologySuite.Geometries.GeometryCollection\">GeometryCollection</xref>s may contain geometries of different dimensions, nested to any level.\nThe element geometries may overlap in any combination.\nThe OGC specification did not provide a definition for the topology\nof GeometryCollections, or how they behave under the DE-9IM model.\nRelateNG defines the topology for arbitrary collections of geometries\nusing &quot;union semantics&quot;.\nThis is specified as:</p>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"70\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"70\">GeometryCollections are evaluated as if they were replaced by the topological union\nof their elements.</li>\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"72\">The topological location at a point is equal to its location in the geometry of highest\ndimension which contains it.  For example, a point located in the interior of a Polygon\nand the boundary of a LineString has location <code sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"74\">Interior</code>.</li>\n</ul>\n<h3 id=\"zero-length-linestring-handling\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"76\">Zero-length LineString Handling</h3>\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"77\">Zero-length LineStrings are handled as topologically identical to a Point at the same coordinate.</p>\n<h2 id=\"package-specification\" sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"79\">Package Specification</h2>\n<ul sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"80\">\n<li sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.RelateNG.md\" sourcestartlinenumber=\"80\"><a href=\"http://www.opengis.org/techno/specs.htm\">OpenGIS Simple Features Specification for SQL</a></li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.CascadedPolygonUnion.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.CascadedPolygonUnion.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union.CascadedPolygonUnion",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Union.CascadedPolygonUnion.yml\" sourcestartlinenumber=\"1\">Provides an efficient method of unioning a collection of\n<xref href=\"NetTopologySuite.Geometries.IPolygonal\" data-throw-if-not-resolved=\"false\"></xref> geometries.\nThe geometries are indexed using a spatial index,\nand unioned recursively in index order.\nFor geometries with a high degree of overlap,\nthis has the effect of reducing the number of vertices\nearly in the process, which increases speed\nand robustness.</p>\n<p></p>\nThis algorithm is faster and more robust than\nthe simple iterated approach of\nrepeatedly unioning each polygon to a result geometry.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.OverlapUnion.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.OverlapUnion.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union.OverlapUnion",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Union.OverlapUnion.yml\" sourcestartlinenumber=\"1\">Unions MultiPolygons efficiently by\nusing full topological union only for polygons which may overlap,\nand combining with the remaining polygons.\nPolygons which may overlap are those which intersect the common extent of the inputs.\nPolygons wholly outside this extent must be disjoint to the computed union.\nThey can thus be simply combined with the union result,\nwhich is much more performant.\n(There is one caveat to this, which is discussed below).</p>\n<p></p>\nThis situation is likely to occur during cascaded polygon union,\nsince the partitioning of polygons is done heuristically\nand thus may group disjoint polygons which can lie far apart.\nIt may also occur in real world data which contains many disjoint polygons\n(e.g. polygons representing parcels on different street blocks).\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.PointGeometryUnion.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.PointGeometryUnion.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union.PointGeometryUnion",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.UnaryUnionOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.UnaryUnionOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union.UnaryUnionOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Union.UnaryUnionOp.yml\" sourcestartlinenumber=\"1\">Unions a <code>Collection</code> of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s or a single Geometry (which may be a <xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref>) together.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.UnionInteracting.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.UnionInteracting.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union.UnionInteracting",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Union.UnionInteracting.yml\" sourcestartlinenumber=\"1\">Experimental code to union MultiPolygons with processing limited to the elements which actually interact.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.UnionStrategy.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.UnionStrategy.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union.UnionStrategy",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Union.UnionStrategy.yml\" sourcestartlinenumber=\"1\">An strategy class that allows UnaryUnion to adapt to different\nkinds of overlay algorithms.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Union.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Union.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Union",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.ConnectedInteriorTester",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.yml\" sourcestartlinenumber=\"1\">This class tests that the interior of an area <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\n(<xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.MultiPolygon\" data-throw-if-not-resolved=\"false\"></xref>)\nis connected.  An area Geometry is invalid if the interior is disconnected.\nThis can happen if:</p>\n<ul sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.yml\" sourcestartlinenumber=\"5\">\n<li sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.yml\" sourcestartlinenumber=\"5\">a shell self-intersects,</li>\n<li sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.yml\" sourcestartlinenumber=\"6\">one or more holes form a connected chain touching a shell at two different points,</li>\n<li sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.ConnectedInteriorTester.yml\" sourcestartlinenumber=\"7\">one or more holes form a ring around a subset of the interior.\nIf a disconnected situation is found the location of the problem is recorded.</li>\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.ConsistentAreaTester.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.ConsistentAreaTester.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.ConsistentAreaTester",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.ConsistentAreaTester.yml\" sourcestartlinenumber=\"1\">Checks that a <xref href=\"NetTopologySuite.GeometriesGraph.GeometryGraph\" data-throw-if-not-resolved=\"false\"></xref> representing an area\n(a <code>Polygon</code> or <code>MultiPolygon</code> )\nis consistent with the SFS semantics for area geometries.\nChecks include:\nTesting for rings which self-intersect (both properly and at nodes).\nTesting for duplicate rings.\nIf an inconsistency if found the location of the problem is recorded.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.IndexedNestedRingTester.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.IndexedNestedRingTester.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.IndexedNestedRingTester",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.IndexedNestedRingTester.yml\" sourcestartlinenumber=\"1\">Tests whether any of a set of <xref href=\"NetTopologySuite.Geometries.LinearRing\" data-throw-if-not-resolved=\"false\"></xref>s are\nnested inside another ring in the set, using a spatial\nindex to speed up the comparisons.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.IsSimpleOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.IsSimpleOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.IsSimpleOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.IsSimpleOp.yml\" sourcestartlinenumber=\"1\">Tests whether a <code>Geometry</code> is simple as defined by the OGC SFS specification.</p>\n<p></p>\nSimplicity is defined for each <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\ntype as follows:\n<ul><li><span class=\"term\">Point</span>geometries are simple.</li><li><span class=\"term\">MultiPoint</span>geometries are simple if every point is unique</li><li><span class=\"term\">LineString</span>geometries are simple if they do not self-intersect at interior points\n(i.e.points other than the endpoints).\nClosed linestrings which intersect only at their endpoints are simple\n(i.e. valid <b>LinearRings</b>s.\n</li><li><span class=\"term\">MultiLineString</span>geometries are simple if \ntheir elements are simple and they intersect only at points \nwhich are boundary points of both elements. \n(The notion of boundary points can be user-specified - see below).</li><li><span class=\"term\">Polygonal</span>geometries have no definition of simplicity.\nThe <code>IsSimple</code> code checks if all polygon rings are simple.\n(Note: this means that<tt>IsSimple</tt> cannot be used to test \nfor <i>all</i> self-intersections in <tt>Polygon</tt> s.  \nIn order to check if a <tt>IPolygonal</tt> geometry has self-intersections,\nuse <xref href=\"NetTopologySuite.Geometries.Geometry.IsValid\" data-throw-if-not-resolved=\"false\"></xref>.</li><li><span class=\"term\">GeometryCollection</span>geometries are simple if all their elements are simple.</li><li>Empty geometries are simple</li></ul>\nFor <xref href=\"NetTopologySuite.Geometries.ILineal\" data-throw-if-not-resolved=\"false\"></xref> geometries the evaluation of simplicity\ncan be customized by supplying a <xref href=\"NetTopologySuite.Algorithm.IBoundaryNodeRule\" data-throw-if-not-resolved=\"false\"></xref>\nto define how boundary points are determined.\nThe default is the SFS-standard <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.Mod2BoundaryRule\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nNote that under the <tt>Mod-2</tt> rule, closed <tt>LineString</tt>s (rings)\nhave no boundary.\nThis means that an intersection at the endpoints of\ntwo closed LineStrings makes the geometry non-simple.\nThis means that an intersection at their endpoints makes the geometry non-simple.\nIf it is required to test whether a set of <code>LineString</code>s touch\nonly at their endpoints, use <xref href=\"NetTopologySuite.Algorithm.BoundaryNodeRules.EndpointBoundaryRule\" data-throw-if-not-resolved=\"false\"></xref>.\nFor example, this can be used to validate that a collection of lines\nform a topologically valid linear network.\n<p></p>\nBy default this class finds a single non-simple location.\nTo find all non-simple locations, set <xref href=\"NetTopologySuite.Operation.Valid.IsSimpleOp.FindAllLocations\" data-throw-if-not-resolved=\"false\"></xref>\nbefore calling <xref href=\"NetTopologySuite.Operation.Valid.IsSimpleOp.IsSimple\" data-throw-if-not-resolved=\"false\"></xref>, and retrieve the locations\nvia <xref href=\"NetTopologySuite.Operation.Valid.IsSimpleOp.NonSimpleLocations\" data-throw-if-not-resolved=\"false\"></xref>.\nThis can be used to find all intersection points in a linear network.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.IsValidOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.IsValidOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.IsValidOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.IsValidOp.yml\" sourcestartlinenumber=\"1\">Implements the algorithms required to compute the <xref href=\"NetTopologySuite.Geometries.Geometry.IsValid\" data-throw-if-not-resolved=\"false\"></xref>\nmethod for <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s.\nSee the documentation for the various geometry types for a specification of validity.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.RepeatedPointTester.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.RepeatedPointTester.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.RepeatedPointTester",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.RepeatedPointTester.yml\" sourcestartlinenumber=\"1\">Implements the appropriate checks for repeated points\n(consecutive identical coordinates) as defined in the\nNTS spec.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.TopologyValidationError.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.TopologyValidationError.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.TopologyValidationError",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.TopologyValidationError.yml\" sourcestartlinenumber=\"1\">Contains information about the nature and location of a <code>Geometry</code>\nvalidation error.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.TopologyValidationErrors.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.TopologyValidationErrors.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid.TopologyValidationErrors",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Operation.Valid.TopologyValidationErrors.yml\" sourcestartlinenumber=\"1\">Contains information about the nature and location of\na <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> validation error.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.Valid.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.Valid.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation.Valid",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.Valid.md\" sourcestartlinenumber=\"5\">Classes for testing the validity and simplicity of geometries,\nas defined in the OGC Simple Features specification.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Operation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Operation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Operation",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Operation.md\" sourcestartlinenumber=\"5\">Provides classes for implementing operations on geometries</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder.yml\" sourcestartlinenumber=\"1\">Finds all connected <xref href=\"NetTopologySuite.Planargraph.Subgraph\" data-throw-if-not-resolved=\"false\"></xref>s of a <xref href=\"NetTopologySuite.Planargraph.PlanarGraph\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.Algorithm.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.Algorithm.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.Algorithm",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.DirectedEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.DirectedEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.DirectedEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.DirectedEdge.yml\" sourcestartlinenumber=\"1\">Represents a directed edge in a <code>PlanarGraph</code>. A DirectedEdge may or\nmay not have a reference to a parent Edge (some applications of\nplanar graphs may not require explicit Edge objects to be created). Usually\na client using a <code>PlanarGraph</code> will subclass <code>DirectedEdge</code>\nto add its own application-specific data and methods.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.DirectedEdgeStar.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.DirectedEdgeStar.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.DirectedEdgeStar",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.DirectedEdgeStar.yml\" sourcestartlinenumber=\"1\">A sorted collection of <code>DirectedEdge</code>s which leave a <code>Node</code>\nin a <code>PlanarGraph</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.Edge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.Edge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.Edge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.Edge.yml\" sourcestartlinenumber=\"1\">Represents an undirected edge of a {PlanarGraph}. An undirected edge\nin fact simply acts as a central point of reference for two opposite\n<code>DirectedEdge</code>s.\nUsually a client using a <code>PlanarGraph</code> will subclass <code>Edge</code>\nto add its own application-specific data and methods.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.GraphComponent.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.GraphComponent.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.GraphComponent",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.GraphComponent.yml\" sourcestartlinenumber=\"1\">The base class for all graph component classes.\nMaintains flags of use in generic graph algorithms.\nProvides two flags:\nmarked - typically this is used to indicate a state that persists\nfor the course of the graph's lifetime.  For instance, it can be\nused to indicate that a component has been logically deleted from the graph.\nvisited - this is used to indicate that a component has been processed\nor visited by an single graph algorithm.  For instance, a breadth-first traversal of the\ngraph might use this to indicate that a node has already been traversed.\nThe visited flag may be set and cleared many times during the lifetime of a graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.Node.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.Node.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.Node",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.Node.yml\" sourcestartlinenumber=\"1\">A node in a <code>PlanarGraph</code> is a location where 0 or more <code>Edge</code>s\nmeet. A node is connected to each of its incident Edges via an outgoing\nDirectedEdge. Some clients using a <code>PlanarGraph</code> may want to\nsubclass <code>Node</code> to add their own application-specific\ndata and methods.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.NodeMap.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.NodeMap.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.NodeMap",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.NodeMap.yml\" sourcestartlinenumber=\"1\">A map of <xref href=\"NetTopologySuite.Planargraph.Node?text=nodes\" data-throw-if-not-resolved=\"false\"></xref>, indexed by the coordinate of the node.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.PlanarGraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.PlanarGraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.PlanarGraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.PlanarGraph.yml\" sourcestartlinenumber=\"1\">Represents a directed graph which is embeddable in a planar surface.\nThis class and the other classes in this package serve as a framework for\nbuilding planar graphs for specific algorithms. This class must be\nsubclassed to expose appropriate methods to construct the graph. This allows\ncontrolling the types of graph components ({DirectedEdge}s,\n<code>Edge</code>s and <code>Node</code>s) which can be added to the graph. An\napplication which uses the graph framework will almost always provide\nsubclasses for one or more graph components, which hold application-specific\ndata and graph algorithms.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.Subgraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.Subgraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph.Subgraph",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Planargraph.Subgraph.yml\" sourcestartlinenumber=\"1\">A subgraph of a <xref href=\"NetTopologySuite.Planargraph.PlanarGraph\" data-throw-if-not-resolved=\"false\"></xref>.\nA subgraph may contain any subset of <xref href=\"NetTopologySuite.Planargraph.Edge\" data-throw-if-not-resolved=\"false\"></xref>s\nfrom the parent graph.\nIt will also automatically contain all <xref href=\"NetTopologySuite.Planargraph.DirectedEdge\" data-throw-if-not-resolved=\"false\"></xref>s\nand <xref href=\"NetTopologySuite.Planargraph.Node\" data-throw-if-not-resolved=\"false\"></xref>s associated with those edges.\nNo new objects are created when edges are added -\nall associated components must already exist in the parent graph.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Planargraph.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Planargraph.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Planargraph",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Planargraph.md\" sourcestartlinenumber=\"5\">Contains classes to implement a planar graph data structure.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.CommonBits.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.CommonBits.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.CommonBits",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.CommonBits.yml\" sourcestartlinenumber=\"1\">Determines the maximum number of common most-significant\nbits in the mantissa of one or numbers.\nCan be used to compute the double-precision number which\nis represented by the common bits.\nIf there are no common bits, the number computed is 0.0.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.CommonBitsOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.CommonBitsOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.CommonBitsOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.CommonBitsOp.yml\" sourcestartlinenumber=\"1\">Provides versions of Geometry spatial functions which use\ncommon bit removal to reduce the likelihood of robustness problems.\nIn the current implementation no rounding is performed on the\nreshifted result point, which means that it is possible\nthat the returned Geometry is invalid.\nClient classes should check the validity of the returned result themselves.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinateFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinateFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.CommonBitsRemover.CommonCoordinateFilter",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.CommonBitsRemover.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.CommonBitsRemover.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.CommonBitsRemover",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.CommonBitsRemover.yml\" sourcestartlinenumber=\"1\">Removes common most-significant mantissa bits\nfrom one or more <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s.</p>\n<p></p>\nThe CommonBitsRemover \"scavenges\" precision\nwhich is \"wasted\" by a large displacement of the geometry\nfrom the origin.\nFor example, if a small geometry is displaced from the origin\nby a large distance,\nthe displacement increases the significant figures in the coordinates,\nbut does not affect the <i>relative</i> topology of the geometry.\nThus the geometry can be translated back to the origin\nwithout affecting its topology.\nIn order to compute the translation without affecting\nthe full precision of the coordinate values,\nthe translation is performed at the bit level by\nremoving the common leading mantissa bits.\n<p></p>\nIf the geometry envelope already contains the origin,\nthe translation procedure cannot be applied.\nIn this case, the common bits value is computed as zero.\n<p></p>\nIf the geometry crosses the Y axis but not the X axis\n(and <i>mutatis mutandum</i>),\nthe common bits for Y are zero,\nbut the common bits for X are non-zero.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.CoordinatePrecisionReducerFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.CoordinatePrecisionReducerFilter.yml\" sourcestartlinenumber=\"1\">Reduces the precision of the <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s in a\n<xref href=\"NetTopologySuite.Geometries.CoordinateSequence\" data-throw-if-not-resolved=\"false\"></xref> to match the supplied <xref href=\"NetTopologySuite.Geometries.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.EnhancedPrecisionOp.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.EnhancedPrecisionOp.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.EnhancedPrecisionOp",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.EnhancedPrecisionOp.yml\" sourcestartlinenumber=\"1\">Provides versions of Geometry spatial functions which use\nenhanced precision techniques to reduce the likelihood of robustness problems.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.GeometryPrecisionReducer.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.GeometryPrecisionReducer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.GeometryPrecisionReducer",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.GeometryPrecisionReducer.yml\" sourcestartlinenumber=\"1\">Reduces the precision of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>\naccording to the supplied <xref href=\"NetTopologySuite.Geometries.PrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>,\nensuring that the result is valid (unless specified otherwise).</p>\n<p></p>\nBy default the geometry precision model is not changed.\nThis can be overridden by using <xref href=\"NetTopologySuite.Precision.GeometryPrecisionReducer.ChangePrecisionModel\" data-throw-if-not-resolved=\"false\"></xref>.\n<h4>Topological Precision Reduction</h4>\nThe default mode of operation ensures the reduced result is topologically valid\n(i.e. <xref href=\"NetTopologySuite.Geometries.Geometry.IsValid\" data-throw-if-not-resolved=\"false\"></xref> is true).\nTo ensure this polygonal geometry is reduced in a topologically valid fashion\n(technically, by using snap-rounding).\nNote that this may change polygonal geometry structure\n(e.g.two polygons separated by a distance below the specified precision\nwill be merged into a single polygon).\nDuplicate vertices are removed.\nThis mode is invoked by the static method <xref href=\"NetTopologySuite.Precision.GeometryPrecisionReducer.Reduce(NetTopologySuite.Geometries.Geometry%2cNetTopologySuite.Geometries.PrecisionModel)\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nNormally, collapsed linear components(e.g.lines collapsing to a point)\nare not included in the result.\nThis behavior can be changed\nby setting <xref href=\"NetTopologySuite.Precision.GeometryPrecisionReducer.RemoveCollapsedComponents\" data-throw-if-not-resolved=\"false\"></xref> to <code>false</code>,\nor by using the static method <xref href=\"NetTopologySuite.Precision.GeometryPrecisionReducer.ReduceKeepCollapsed(NetTopologySuite.Geometries.Geometry%2cNetTopologySuite.Geometries.PrecisionModel)\" data-throw-if-not-resolved=\"false\"></xref>.\n<p></p>\nIn general input must be valid geometry, or an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>\nwill be thrown. However if the invalidity is \"mild\" or very small then it\nmay be eliminated by precision reduction.\n<h4> Pointwise Precision Reduction</h4>\nAlternatively, geometry can be reduced pointwise by using {@link #setPointwise(boolean)}.\nLinear and point geometry are always reduced pointwise(i.e.without further change to\ntopology or structure), since this does not change validity.\nInvalid inputs are allowed.\nDuplicate vertices are preserved.\nCollapsed components are always included in the result.\nThe result geometry may be invalid.\n<p></p>\nThis mode is invoked by the static method <xref href=\"NetTopologySuite.Precision.GeometryPrecisionReducer.ReducePointwise(NetTopologySuite.Geometries.Geometry%2cNetTopologySuite.Geometries.PrecisionModel)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.MinimumClearance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.MinimumClearance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.MinimumClearance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.MinimumClearance.yml\" sourcestartlinenumber=\"1\">Computes the Minimum Clearance of a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nThe <b>Minimum Clearance</b> is a measure of\nwhat magnitude of perturbation of\nthe vertices of a geometry can be tolerated\nbefore the geometry becomes topologically invalid.\nThe smaller the Minimum Clearance distance,\nthe less vertex perturbation the geometry can tolerate\nbefore becoming invalid.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.PrecisionReducerCoordinateOperation.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.PrecisionReducerCoordinateOperation.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.PrecisionReducerCoordinateOperation",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.SimpleMinimumClearance.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.SimpleMinimumClearance.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision.SimpleMinimumClearance",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Precision.SimpleMinimumClearance.yml\" sourcestartlinenumber=\"1\">Computes the minimum clearance of a geometry or\nset of geometries.<p></p>\nThe <b>Minimum Clearance</b> is a measure of\nwhat magnitude of perturbation of its vertices can be tolerated\nby a geometry before it becomes topologically invalid.\n<p></p>\nThis class uses an inefficient O(N^2) scan.\nIt is primarily for testing purposes.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Precision.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Precision.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Precision",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Precision.md\" sourcestartlinenumber=\"5\">Provides classes for analyzing and manipulating the precision of Geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.CubicBezierCurve.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.CubicBezierCurve.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.CubicBezierCurve",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.CubicBezierCurve.yml\" sourcestartlinenumber=\"1\">Creates a curved geometry by replacing the segments\nof the input with Cubic Bezier Curves.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.HilbertCode.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.HilbertCode.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal.HilbertCode",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.Fractal.HilbertCode.yml\" sourcestartlinenumber=\"1\">Encodes points as the index along finite planar Hilbert curves.</p>\n<p>\nThe planar Hilbert Curve is a continuous space-filling curve.\nIn the limit the Hilbert curve has infinitely many vertices and fills\nthe space of the unit square.\nA sequence of finite approximations to the infinite Hilbert curve\nis defined by the level number.\nThe finite Hilbert curve at level n Hₙ contains 2ⁿ⁺¹ points.\nEach finite Hilbert curve defines an ordering of the\npoints in the 2-dimensional range square containing the curve.\nCurves fills the range square of side 2ˡᵉᵛᵉˡ.\nCurve points have ordinates in the range [0, 2ˡᵉᵛᵉˡ - 1].\nThe index of a point along a Hilbert curve is called the Hilbert code.\nThe code for a given point is specific to the level chosen.\n</p>\n<p>\nThis implementation represents codes using 32-bit integers.\nThis allows levels 0 to 16 to be handled.\nThe class supports encoding points in the range of a given level curve\nand decoding the point for a given code value.\n</p>\n<p>\nThe Hilbert order has the property that it tends to preserve locality.\nThis means that codes which are near in value will have spatially proximate\npoints.  The converse is not always true - the delta between\ncodes for nearby points is not always small.  But the average delta\nis small enough that the Hilbert order is an effective way of linearizing space\nto support range queries.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.HilbertCurveBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.HilbertCurveBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal.HilbertCurveBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.Fractal.HilbertCurveBuilder.yml\" sourcestartlinenumber=\"1\">Generates a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> representing the Hilbert Curve\nat a given level.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.KochSnowflakeBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.KochSnowflakeBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal.KochSnowflakeBuilder",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.MortonCode.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.MortonCode.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal.MortonCode",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.Fractal.MortonCode.yml\" sourcestartlinenumber=\"1\">Encodes points as the index along the planar Morton (Z-order) curve.</p>\n<p>\nThe planar Morton (Z-order) curve is a continuous space-filling curve.\nThe Morton curve defines an ordering of the\npoints in the positive quadrant of the plane.\nThe index of a point along the Morton curve is called the Morton code.\n</p>\n<p>\nA sequence of subsets of the Morton curve can be defined by a level number.\nEach level subset occupies a square range.\nThe curve at level n Mₙ contains 2ⁿ⁺¹ points.\nIt fills the range square of side 2ˡᵉᵛᵉˡ.\nCurve points have ordinates in the range [0, 2ˡᵉᵛᵉˡ - 1].\nThe code for a given point is identical at all levels.\nThe level simply determines the number of points in the curve subset\nand the size of the range square.\n</p>\n<p>\nThis implementation represents codes using 32-bit integers.\nThis allows levels 0 to 16 to be handled.\nThe class supports encoding points\nand decoding the point for a given code value.\n</p>\n<p>\nThe Morton order has the property that it tends to preserve locality.\nThis means that codes which are near in value will have spatially proximate\npoints.  The converse is not always true - the delta between\ncodes for nearby points is not always small.  But the average delta\nis small enough that the Morton order is an effective way of linearizing space\nto support range queries.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.MortonCurveBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.MortonCurveBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal.MortonCurveBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.Fractal.MortonCurveBuilder.yml\" sourcestartlinenumber=\"1\">Generates a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> representing the Morton Curve\nat a given level.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.SierpinskiCarpetBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.SierpinskiCarpetBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal.SierpinskiCarpetBuilder",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Fractal.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Fractal.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Fractal",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.GeometricShapeBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.GeometricShapeBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.GeometricShapeBuilder",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Random.RandomPointsBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Random.RandomPointsBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Random.RandomPointsBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.Random.RandomPointsBuilder.yml\" sourcestartlinenumber=\"1\">Creates random point sets contained in a\nregion defined by either a rectangular or a polygonal extent.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Random.RandomPointsInGridBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Shape.Random.RandomPointsInGridBuilder.yml\" sourcestartlinenumber=\"1\">Creates random point sets where the points\nare constrained to lie in the cells of a grid.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.Random.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.Random.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape.Random",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Shape.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Shape.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Shape",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.ComponentJumpChecker.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.ComponentJumpChecker.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.ComponentJumpChecker",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.ComponentJumpChecker.yml\" sourcestartlinenumber=\"1\">Checks if simplifying (flattening) line sections or segments\nwould cause them to &quot;jump&quot; over other components in the geometry.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a line (sequence of points) using\nthe standard Douglas-Peucker algorithm.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.DouglasPeuckerSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.DouglasPeuckerSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.DouglasPeuckerSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.DouglasPeuckerSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> using the Douglas-Peucker algorithm.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.LineSegmentIndex.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.LineSegmentIndex.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.LineSegmentIndex",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.LineSegmentIndex.yml\" sourcestartlinenumber=\"1\">An index of LineSegments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.LineSegmentVisitor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.LineSegmentVisitor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.LineSegmentVisitor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.LineSegmentVisitor.yml\" sourcestartlinenumber=\"1\">ItemVisitor subclass to reduce volume of query results.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.OldVWLineSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.OldVWLineSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.OldVWLineSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.OldVWLineSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a linestring (sequence of points) using the\nVisvalingam-Whyatt algorithm.\nThe Visvalingam-Whyatt algorithm simplifies geometry\nby removing vertices while trying to minimize the area changed.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.PolygonHullSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.PolygonHullSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.PolygonHullSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.PolygonHullSimplifier.yml\" sourcestartlinenumber=\"1\">Computes topology-preserving simplified hulls of polygonal geometry.\nBoth outer and inner hulls can be computed.\nOuter hulls contain the input geometry and are larger in area.\nInner hulls are contained by the input geometry and are smaller in area.\nIn both the hull vertices are a subset of the input vertices.\nThe hull construction attempts to minimize the area difference\nwith the input geometry.</p>\n<p></p>\nHulls are generally concave if the input is.\nComputed hulls are topology-preserving: \nthey do not contain any self-intersections or overlaps, \nso the result polygonal geometry is valid.\n<p></p>\nPolygons with holes and MultiPolygons are supported.\nThe result has the same geometric type and structure as the input.\n<p></p>\nThe number of vertices in the computed hull is determined by a target parameter.\nTwo parameters are supported:\n<ul><li><span class=\"term\">Vertex Number fraction</span>the fraction of the input vertices retained in the result.\nValue 1 produces the original geometry.\nSmaller values produce less concave results.\nFor outer hulls, value 0 produces the convex hull (with triangles for any holes).\nFor inner hulls, value 0 produces a triangle (if no holes are present).</li><li><span class=\"term\">Area Delta ratio</span>\nthe ratio of the change in area to the input area.Value 0 produces the original geometry.\nLarger values produce less concave results.</li></ul>\nThe algorithm ensures that the result does not cause the target parameter\nto be exceeded. This allows computing outer or inner hulls\nwith a small area delta ratio as an effective way of removing\nnarrow gores and spikes.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.TaggedLineSegment.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.TaggedLineSegment.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.TaggedLineSegment",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.TaggedLineSegment.yml\" sourcestartlinenumber=\"1\">A LineSegment which is tagged with its location in a <code>Geometry</code>.\nUsed to index the segments in a point and recover the segment locations\nfrom the index.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.TaggedLineString.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.TaggedLineString.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.TaggedLineString",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.TaggedLineString.yml\" sourcestartlinenumber=\"1\">Represents a <xref href=\"NetTopologySuite.Geometries.LineString\" data-throw-if-not-resolved=\"false\"></xref> which can be modified to a simplified shape.\nThis class provides an attribute which specifies the minimum allowable length\nfor the modified result.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.TaggedLineStringSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.TaggedLineStringSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.TaggedLineStringSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.TaggedLineStringSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a TaggedLineString, preserving topology\n(in the sense that no new intersections are introduced).\nUses the recursive Douglas-Peucker  algorithm.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.TaggedLinesSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.TaggedLinesSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.TaggedLinesSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.TaggedLinesSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a collection of <code>TaggedLineString</code>s, preserving topology\n(in the sense that no new intersections are introduced).\nThis class is essentially just a container for the common\nindexes used by <xref href=\"NetTopologySuite.Simplify.TaggedLineStringSimplifier\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.TopologyPreservingSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.TopologyPreservingSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.TopologyPreservingSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.TopologyPreservingSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a point and ensures that\nthe result is a valid point having the\nsame dimension and number of components as the input,\nand with the components having the same topological relationship.</p>\n<p></p>\nIf the input is a polygonal geometry\n(<xref href=\"NetTopologySuite.Geometries.Polygon\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"NetTopologySuite.Geometries.MultiPolygon\" data-throw-if-not-resolved=\"false\"></xref>):\n<ul><li>The result has the same number of shells and holes as the input,\n with the same topological structure</li><li>The result rings touch at no more than the number of touching points in the input\n(although they may touch at fewer points).\nThe key implication of this statement is that if the\ninput is topologically valid, so is the simplified output.</li></ul>\nFor linear geometries, if the input does not contain\nany intersecting line segments, this property\nwill be preserved in the output.\n<p></p>\n<p>\nFor polygonal geometries and LinearRings the endpoint will ring endpoint will be simplified.\nFor LineStrings the endpoints will be unchanged.\n</p>\nFor all geometry types, the result will contain\nenough vertices to ensure validity.  For polygons\nand closed linear geometries, the result will have at\nleast 4 vertices; for open LineStrings the result\nwill have at least 2 vertices.\n<p></p>\nAll geometry types are handled.\nEmpty and point geometries are returned unchanged.\nEmpty geometry components are deleted.\n<p></p>\nThe simplification uses a maximum-distance difference algorithm\nsimilar to the Douglas-Peucker algorithm.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.VWLineSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.VWLineSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.VWLineSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.VWLineSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a linestring (sequence of points) using the\nVisvalingam-Whyatt algorithm.\nThe Visvalingam-Whyatt algorithm simplifies geometry\nby removing vertices while trying to minimize the area changed.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.VWSimplifier.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.VWSimplifier.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify.VWSimplifier",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Simplify.VWSimplifier.yml\" sourcestartlinenumber=\"1\">Simplifies a <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref> using the Visvalingam-Whyatt area-based algorithm.\nEnsures that any polygonal geometries returned are valid. Simple lines are not\nguaranteed to remain simple after simplification. All geometry types are\nhandled. Empty and point geometries are returned unchanged. Empty geometry\ncomponents are deleted.\nThe simplification tolerance is specified as a distance.\nThis is converted to an area tolerance by squaring it.</p>\n<p>\n<b>Known Bugs</b>\n* Not yet optimized for performance.\n* Does not simplify the endpoint of rings.\n<b>To Do</b>\n* Allow specifying desired number of vertices in the output.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Simplify.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Simplify.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Simplify",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Simplify.md\" sourcestartlinenumber=\"5\">Classes which implement algorithms for simplifying or generalizing geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder.yml\" sourcestartlinenumber=\"1\">A utility class which creates Conforming Delaunay Triangulations\nfrom collections of points and linear constraints, and extract the resulting\ntriangulation edges or triangles as geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.ConformingDelaunayTriangulator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.ConformingDelaunayTriangulator.yml\" sourcestartlinenumber=\"1\">Computes a Conforming Delaunay Triangulation over a set of sites and a set of\nlinear constraints.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.ConstraintEnforcementException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.ConstraintEnforcementException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.ConstraintEnforcementException",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.ConstraintEnforcementException.yml\" sourcestartlinenumber=\"1\">Indicates a failure during constraint enforcement.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.ConstraintVertex.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.ConstraintVertex.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.ConstraintVertex",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.ConstraintVertex.yml\" sourcestartlinenumber=\"1\">A vertex in a Constrained Delaunay Triangulation.\nThe vertex may or may not lie on a constraint.\nIf it does it may carry extra information about the original constraint.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.ConstraintVertexFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.ConstraintVertexFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.ConstraintVertexFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.ConstraintVertexFactory.yml\" sourcestartlinenumber=\"1\">An interface for factories which create a <xref href=\"NetTopologySuite.Triangulate.ConstraintVertex\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.DelaunayTriangulationBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.DelaunayTriangulationBuilder.yml\" sourcestartlinenumber=\"1\">A utility class which creates Delaunay Triangulations\nfrom collections of points and extract the resulting\ntriangulation edges or triangles as geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.IConstraintSplitPointFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.IConstraintSplitPointFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.IConstraintSplitPointFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.IConstraintSplitPointFinder.yml\" sourcestartlinenumber=\"1\">An interface for strategies for determining the location of split points on constraint segments.\nThe location of split points has a large effect on the performance and robustness of enforcing a\nconstrained Delaunay triangulation. Poorly chosen split points can cause repeated splitting,\nespecially at narrow constraint angles, since the split point will end up encroaching on the\nsegment containing the original encroaching point. With detailed knowledge of the geometry of the\nconstraints, it is sometimes possible to choose better locations for splitting.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator.yml\" sourcestartlinenumber=\"1\">Computes a Delaunay Triangulation of a set of <xref href=\"NetTopologySuite.Triangulate.QuadEdge.Vertex\" data-throw-if-not-resolved=\"false\"></xref>es, using an\nincremental insertion algorithm.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.MidpointSplitPointFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.MidpointSplitPointFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.MidpointSplitPointFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.MidpointSplitPointFinder.yml\" sourcestartlinenumber=\"1\">A simple split point finder which returns the midpoint of the split segment. This is a default\nstrategy only. Usually a more sophisticated strategy is required to prevent repeated splitting.\nOther points which could be used are:</p>\n<ul>\n<li>The projection of the encroaching point on the segment</li>\n<li>A point on the segment which will produce two segments which will not be further encroached</li>\n<li>The point on the segment which is the same distance from an endpoint as the encroaching</li>\npoint\n</ul>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder.yml\" sourcestartlinenumber=\"1\">A strategy for finding constraint split points which attempts to maximise the length of the split\nsegments while preventing further encroachment. (This is not always possible for narrow angles).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator.yml\" sourcestartlinenumber=\"1\">Computes the Constrained Delaunay Triangulation of polygons.\nThe Constrained Delaunay Triangulation of a polygon is a set of triangles\ncovering the polygon, with the maximum total interior angle over all\npossible triangulations.  It provides the &quot;best quality&quot; triangulation\nof the polygon.</p>\n<p></p>\nHoles are supported.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner.yml\" sourcestartlinenumber=\"1\">Transforms a polygon with holes into a single self-touching (invalid) ring\nby joining holes to the exterior shell or to another hole\nwith out-and-back line segments.\nThe holes are added in order of their envelopes (leftmost/lowest first).\nAs the result shell develops, a hole may be added to what was\noriginally another hole.</p>\n<p></p>\nThere is no attempt to optimize the quality of the join lines.\nIn particular, holes may be joined by lines longer than is optimal.\nHowever, holes which touch the shell or other holes are joined at the touch point.\n<p></p>\nThe class does not require the input polygon to have normal\norientation (shell CW and rings CCW).\nThe output ring is always CW.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Polygon.PolygonTriangulator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.yml\" sourcestartlinenumber=\"1\">Computes a triangulation of each polygon in a {<xref href=\"link\" data-throw-if-not-resolved=\"False\" data-raw-source=\"@link\" sourcefile=\"obj/api/NetTopologySuite.Triangulate.Polygon.PolygonTriangulator.yml\" sourcestartlinenumber=\"1\"></xref> Geometry}.\nA polygon triangulation is a non-overlapping set of triangles which\ncover the polygon and have the same vertices as the polygon.\nThe priority is on performance rather than triangulation quality,\nso that the output may contain many narrow triangles.</p>\n<p></p>\nHoles are handled by joining them to the shell to form a\n(self-touching) polygon shell with no holes.\nAlthough invalid, this can be triangulated effectively.\n<p></p>\nFor better-quality triangulation use <xref href=\"NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Polygon.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Polygon.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Polygon",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Triangulate.Polygon.md\" sourcestartlinenumber=\"5\">Classes for triangulating polygons.\n<xref href=\"NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator\">ConstrainedDelaunayTriangulator</xref> can be used to provide high-quality\nnear-Delaunay triangulations of polygonal geometry.\nThe <xref href=\"NetTopologySuite.Triangulate.Polygon.PolygonTriangulator\">PolygonTriangulator</xref> produces lower-quality but faster triangulations.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal.yml\" sourcestartlinenumber=\"1\">A framework to visit sets of edge-connected <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle\" data-throw-if-not-resolved=\"false\"></xref>s in breadth-first order</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator.yml\" sourcestartlinenumber=\"1\">An interface for classes which locate an edge in a <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision\" data-throw-if-not-resolved=\"false\"></xref>\nwhich either contains a given <xref href=\"NetTopologySuite.Triangulate.QuadEdge.Vertex\" data-throw-if-not-resolved=\"false\"></xref> V\nor is an edge of a triangle which contains V.\nImplementors may utilized different strategies for\noptimizing locating containing edges/triangles.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor.yml\" sourcestartlinenumber=\"1\">Interface for classes which process triangles visited during traversals of a\n<xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor.yml\" sourcestartlinenumber=\"1\">An interface for algorithms which process the triangles in a <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator.yml\" sourcestartlinenumber=\"1\">Locates <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdge\" data-throw-if-not-resolved=\"false\"></xref>s in a <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision\" data-throw-if-not-resolved=\"false\"></xref>,\noptimizing the search by starting in the\nlocality of the last edge found.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.LocateFailureException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.LocateFailureException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.LocateFailureException",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.QuadEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.QuadEdge",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdge.yml\" sourcestartlinenumber=\"1\">A class that represents the edge data structure which implements the quadedge algebra.\nThe quadedge algebra was described in a well-known paper by Guibas and Stolfi,\n&quot;Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams&quot;,\n<i>ACM Transactions on Graphics</i>, 4(2), 1985, 75-123.</p>\n<p>\nEach edge object is part of a quartet of 4 edges,\nlinked via their <tt>Rot</tt> references.\nAny edge in the group may be accessed using a series of <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdge.Rot\" data-throw-if-not-resolved=\"false\"></xref> operations.\nQuadedges in a subdivision are linked together via their <tt>Next</tt> references.\nThe linkage between the quadedge quartets determines the topology\nof the subdivision.\n</p>\n<p>\nThe edge class does not contain separate information for vertices or faces; a vertex is implicitly\ndefined as a ring of edges (created using the <tt>Next</tt> field).\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision.yml\" sourcestartlinenumber=\"1\">A class that contains the <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdge\" data-throw-if-not-resolved=\"false\"></xref>s representing a planar\nsubdivision that models a triangulation.\nThe subdivision is constructed using the\nquadedge algebra defined in the class <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdge\" data-throw-if-not-resolved=\"false\"></xref>.\nAll metric calculations\nare done in the <xref href=\"NetTopologySuite.Triangulate.QuadEdge.Vertex\" data-throw-if-not-resolved=\"false\"></xref> class.\nIn addition to a triangulation, subdivisions\nsupport extraction of Voronoi diagrams.\nThis is easily accomplished, since the Voronoi diagram is the dual\nof the Delaunay triangulation.</p>\n<p>\nSubdivisions can be provided with a tolerance value. Inserted vertices which\nare closer than this value to vertices already in the subdivision will be\nignored. Using a suitable tolerance value can prevent robustness failures\nfrom happening during Delaunay triangulation.\n</p>\n<p>\nSubdivisions maintain a <b>frame</b> triangle around the client-created\nedges. The frame is used to provide a bounded \"container\" for all edges\nwithin a TIN. Normally the frame edges, frame connecting edges, and frame\ntriangles are not included in client processing.\n</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle.yml\" sourcestartlinenumber=\"1\">Models a triangle formed from <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdge\" data-throw-if-not-resolved=\"false\"></xref>s in a <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision\" data-throw-if-not-resolved=\"false\"></xref>\nwhich forms a triangulation. The class provides methods to access the\ntopological and geometric properties of the triangle and its neighbours in\nthe triangulation. Triangle vertices are ordered in CCW orientation in the\nstructure.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeUtil.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.QuadEdgeUtil.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.QuadEdgeUtil",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate.yml\" sourcestartlinenumber=\"1\">Algorithms for computing values and predicates\nassociated with triangles.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.Vertex.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.Vertex.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge.Vertex",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.QuadEdge.Vertex.yml\" sourcestartlinenumber=\"1\">Models a site (node) in a <xref href=\"NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision\" data-throw-if-not-resolved=\"false\"></xref>.\nThe sites can be points on a line string representing a\nlinear site.<p></p>\nThe vertex can be considered as a vector with a norm, length, inner product, cross\nproduct, etc. Additionally, point relations (e.g., is a point to the left of a line, the circle\ndefined by this point and two others, etc.) are also defined in this class.\n<p></p>\nIt is common to want to attach user-defined data to\nthe vertices of a subdivision.\nOne way to do this is to subclass <tt>Vertex</tt>\nto carry any desired information.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.QuadEdge.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.QuadEdge.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.QuadEdge",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Triangulate.QuadEdge.md\" sourcestartlinenumber=\"5\">Classes to implement a topological subdivision of quadeges, to support creating triangulations and Voronoi diagrams.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Segment.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Segment.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Segment",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.Segment.yml\" sourcestartlinenumber=\"1\">Models a constraint segment in a triangulation.\nA constraint segment is an oriented straight line segment between a start point\nand an end point.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.SplitSegment.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.SplitSegment.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.SplitSegment",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.SplitSegment.yml\" sourcestartlinenumber=\"1\">Models a constraint segment which can be split in two in various ways,\naccording to certain geometric constraints.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Tri.Tri.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Tri.Tri.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Tri.Tri",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.Tri.Tri.yml\" sourcestartlinenumber=\"1\">A memory-efficient representation of a triangle in a triangulation.\nContains three vertices, and links to adjacent <code>Tri</code>s for each edge.\n<code>Tri</code>s are constructed independently, and if needed linked\ninto a triangulation using <xref href=\"NetTopologySuite.Triangulate.Tri.TriangulationBuilder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\nAn edge of a Tri in a triangulation is called a boundary edge\nif it has no adjacent triangle.<br>\nThe set of Tris containing boundary edges are called the triangulation border.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Tri.TriangulationBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Tri.TriangulationBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Tri.TriangulationBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.Tri.TriangulationBuilder.yml\" sourcestartlinenumber=\"1\">Builds a triangulation from a set of <xref href=\"NetTopologySuite.Triangulate.Tri.Tri\" data-throw-if-not-resolved=\"false\"></xref>s\nby populating the links to adjacent triangles.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.Tri.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.Tri.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.Tri",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Triangulate.Tri.md\" sourcestartlinenumber=\"5\">Classes for representing a planar triangulation as a set of linked triangles.\nTriangles are represented by memory-efficient <xref href=\"NetTopologySuite.Triangulate.Tri.Tri\">Tri</xref> objects.\nA set of triangles can be linked into a triangulation using <xref href=\"NetTopologySuite.Triangulate.Tri.TriangulationBuilder\">TriangulationBuilder</xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper.yml\" sourcestartlinenumber=\"1\">Creates a map between the vertex <xref href=\"NetTopologySuite.Geometries.Coordinate\" data-throw-if-not-resolved=\"false\"></xref>s of a\nset of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s,\nand the parent geometry, and transfers the source geometry\ndata objects to geometry components tagged with the coordinates.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.VoronoiDiagramBuilder.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.VoronoiDiagramBuilder.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate.VoronoiDiagramBuilder",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Triangulate.VoronoiDiagramBuilder.yml\" sourcestartlinenumber=\"1\">A utility class which creates Voronoi Diagrams\nfrom collections of points.\nThe diagram is returned as a <xref href=\"NetTopologySuite.Geometries.GeometryCollection\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"NetTopologySuite.Triangulate.Polygon\" data-throw-if-not-resolved=\"false\"></xref>s,\nrepresenting the faces of the Voronoi diagram.\n/// The faces are clipped to the larger of:</p>\n<ul><li>an envelope supplied by <xref href=\"NetTopologySuite.Triangulate.VoronoiDiagramBuilder.set_ClipEnvelope(NetTopologySuite.Geometries.Envelope)\" data-throw-if-not-resolved=\"false\"></xref>.</li><li>an envelope determined by the input sites.</li></ul>\nThe <tt>userData</tt> attribute of each face <tt>Polygon</tt> is set to\nthe <tt>Coordinate</tt>  of the corresponding input site.\nThis allows using a <tt>Map</tt> to link faces to data associated with sites.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Triangulate.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Triangulate.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Triangulate",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Triangulate.md\" sourcestartlinenumber=\"5\">Classes to compute Delaunay triangulations.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.AlternativePriorityQueue-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.AlternativePriorityQueue-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.AlternativePriorityQueue<TPriority, TData>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.AlternativePriorityQueue-2.yml\" sourcestartlinenumber=\"1\">An alternative implementation of the priority queue abstract data type.\nThis allows us to do more than <xref href=\"NetTopologySuite.Utilities.PriorityQueue%601\" data-throw-if-not-resolved=\"false\"></xref>, which we\ngot from JTS.  Ultimately, this queue enables scenarios that have more\nfavorable execution speed characteristics at the cost of less favorable\nmemory and usability characteristics.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.Assert.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.Assert.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.Assert",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.Assert.yml\" sourcestartlinenumber=\"1\">A utility for making programming assertions.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.AssertionFailedException.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.AssertionFailedException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.AssertionFailedException",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.CoordinateArrayFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.CoordinateArrayFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.CoordinateArrayFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.CoordinateArrayFilter.yml\" sourcestartlinenumber=\"1\">A <code>CoordinateFilter</code> that creates an array containing every coordinate in a <code>Geometry</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.CoordinateCompare.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.CoordinateCompare.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.CoordinateCompare",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.CoordinateCompare.yml\" sourcestartlinenumber=\"1\">CoordinateCompare is used in the sorting of arrays of Coordinate objects.\nImplements a lexicographic comparison.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.CoordinateCountFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.CoordinateCountFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.CoordinateCountFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.CoordinateCountFilter.yml\" sourcestartlinenumber=\"1\">A <code>CoordinateFilter</code> that counts the total number of coordinates\nin a <code>Geometry</code>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.Degrees.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.Degrees.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.Degrees",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.Degrees.yml\" sourcestartlinenumber=\"1\">Converts degrees to radians.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.EnumUtility.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.EnumUtility.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.EnumUtility",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.FunctionsUtil.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.FunctionsUtil.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.FunctionsUtil",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.FunctionsUtil.yml\" sourcestartlinenumber=\"1\">A utility class to get <xref href=\"NetTopologySuite.Geometries.GeometryFactory\" data-throw-if-not-resolved=\"false\"></xref>s, <xref href=\"NetTopologySuite.Geometries.Envelope\" data-throw-if-not-resolved=\"false\"></xref>s\noff of <xref href=\"NetTopologySuite.Geometries.Geometry\" data-throw-if-not-resolved=\"false\"></xref>s or to build aggregate geometries.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.GeometricShapeFactory.Dimensions.yml\" sourcestartlinenumber=\"1\">A dimension class for <xref href=\"NetTopologySuite.Utilities.GeometricShapeFactory\" data-throw-if-not-resolved=\"false\"></xref>s</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.GeometricShapeFactory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.GeometricShapeFactory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.GeometricShapeFactory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.GeometricShapeFactory.yml\" sourcestartlinenumber=\"1\">Computes various kinds of common geometric shapes.\nAllows various ways of specifying the location and extent of the shapes,\nas well as number of line segments used to form them.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.Global.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.Global.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.Global",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.Guard.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.Guard.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.Guard",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.Guard.yml\" sourcestartlinenumber=\"1\">A guard class</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.HexConverter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.HexConverter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.HexConverter",
      "Summary": ""
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.Memory.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.Memory.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.Memory",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.Memory.yml\" sourcestartlinenumber=\"1\">Utility functions to report memory usage.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.PriorityQueue-1.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.PriorityQueue-1.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.PriorityQueue<T>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.PriorityQueue-1.yml\" sourcestartlinenumber=\"1\">A priority queue over a set of <xref href=\"System.IComparable%601\" data-throw-if-not-resolved=\"false\"></xref> objects.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.PriorityQueueNode-2.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.PriorityQueueNode-2.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.PriorityQueueNode<TPriority, TData>",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.PriorityQueueNode-2.yml\" sourcestartlinenumber=\"1\">A container for a prioritized node that sites in an\n<xref href=\"NetTopologySuite.Utilities.AlternativePriorityQueue%602\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.Radians.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.Radians.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.Radians",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.Radians.yml\" sourcestartlinenumber=\"1\">Converts radians to degress.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.UniqueCoordinateArrayFilter.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.UniqueCoordinateArrayFilter.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities.UniqueCoordinateArrayFilter",
      "Summary": "<p sourcefile=\"obj/api/NetTopologySuite.Utilities.UniqueCoordinateArrayFilter.yml\" sourcestartlinenumber=\"1\">A <xref href=\"NetTopologySuite.Geometries.ICoordinateFilter\" data-throw-if-not-resolved=\"false\"></xref>\nthat extracts a unique array of<code>Coordinate</code> s.\nThe array of coordinates contains no duplicate points.</p>\n<p></p>\nIt preserves the order of the input points.\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.Utilities.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.Utilities.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite.Utilities",
      "Summary": "\n<p sourcefile=\"overwrite/namespaces/NetTopologySuite.Utilities.md\" sourcestartlinenumber=\"5\">Contains support classes for the Net Topology Suite.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/NetTopologySuite.yml",
      "output": {
        ".html": {
          "relative_path": "api/NetTopologySuite.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "NetTopologySuite",
      "Summary": null
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.CharBuffer.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.CharBuffer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.CharBuffer",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.CharBuffer.yml\" sourcestartlinenumber=\"1\">Buffer for characters.  This approximates StringBuilder\nbut is designed to be faster for specific operations.\nThis is about 30% faster for the operations I'm interested in\n(Append, Clear, Length, ToString).\nThis trades off memory for speed.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.CharToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.CharToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.CharToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.CharToken.yml\" sourcestartlinenumber=\"1\">Token type for characters, meaning non-word characters.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.CharTypeBits.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.CharTypeBits.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.CharTypeBits",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.CharTypeBits.yml\" sourcestartlinenumber=\"1\">Bitwise enumeration for character types.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.CommentToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.CommentToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.CommentToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.CommentToken.yml\" sourcestartlinenumber=\"1\">Token type for comments, including line and block\ncomments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.EofToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.EofToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.EofToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.EofToken.yml\" sourcestartlinenumber=\"1\">Represents end of file/stream.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.EolToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.EolToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.EolToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.EolToken.yml\" sourcestartlinenumber=\"1\">Represents end-of-lines (line separator characters).</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.FloatToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.FloatToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.FloatToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.FloatToken.yml\" sourcestartlinenumber=\"1\">Token type for floating point numbers, stored internally as a Double.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.IntToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.IntToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.IntToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.IntToken.yml\" sourcestartlinenumber=\"1\">Token type for integer tokens. This handles both Int32 and Int64.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.QuoteToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.QuoteToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.QuoteToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.QuoteToken.yml\" sourcestartlinenumber=\"1\">Token type for Quotes such as &quot;this is a quote&quot;.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.StreamTokenizer.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.StreamTokenizer.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.StreamTokenizer",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.StreamTokenizer.yml\" sourcestartlinenumber=\"1\">A StreamTokenizer similar to Java's.  This breaks an input stream\n(coming from a TextReader) into Tokens based on various settings.  The settings\nare stored in the TokenizerSettings property, which is a\nStreamTokenizerSettings instance.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.StreamTokenizerSettings.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.StreamTokenizerSettings.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.StreamTokenizerSettings",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.StreamTokenizerSettings.yml\" sourcestartlinenumber=\"1\">This contains the settings that control the behavior of the tokenizer.\nThis is separated from the StreamTokenizer so that common settings\nare easy to package and keep together.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.StreamTokenizerUntermCommentException.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.StreamTokenizerUntermCommentException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.StreamTokenizerUntermCommentException",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.StreamTokenizerUntermCommentException.yml\" sourcestartlinenumber=\"1\">Exception class for unterminated block comments.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.StreamTokenizerUntermException.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.StreamTokenizerUntermException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.StreamTokenizerUntermException",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.StreamTokenizerUntermException.yml\" sourcestartlinenumber=\"1\">Exception class for unterminated tokens.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.StreamTokenizerUntermQuoteException.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.StreamTokenizerUntermQuoteException.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.StreamTokenizerUntermQuoteException",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.StreamTokenizerUntermQuoteException.yml\" sourcestartlinenumber=\"1\">Exception class for unterminated quotes.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.StringToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.StringToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.StringToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.StringToken.yml\" sourcestartlinenumber=\"1\">Abstract base class for string tokens.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.Token.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.Token.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.Token",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.Token.yml\" sourcestartlinenumber=\"1\">Token class used by StreamTokenizer.\nThis represents a single token in the input stream.\nThis is subclassed to provide specific token types,\nsuch as CharToken, FloatToken, etc.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.VerbosityLevel.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.VerbosityLevel.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.VerbosityLevel",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.VerbosityLevel.yml\" sourcestartlinenumber=\"1\">This enumerates verbosity levels.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.WhitespaceToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.WhitespaceToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.WhitespaceToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.WhitespaceToken.yml\" sourcestartlinenumber=\"1\">Token type for whitespace such as spaces and tabs.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.WordToken.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.WordToken.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util.WordToken",
      "Summary": "<p sourcefile=\"obj/api/RTools_NTS.Util.WordToken.yml\" sourcestartlinenumber=\"1\">Token type for words, meaning sequences of word\ncharacters.</p>\n"
    },
    {
      "type": "ManagedReference",
      "source_relative_path": "obj/api/RTools_NTS.Util.yml",
      "output": {
        ".html": {
          "relative_path": "api/RTools_NTS.Util.html"
        }
      },
      "version": "",
      "Uid": null,
      "IsMRef": true,
      "Title": "RTools_NTS.Util",
      "Summary": null
    },
    {
      "type": "Toc",
      "source_relative_path": "obj/api/toc.yml",
      "output": {
        ".html": {
          "relative_path": "api/toc.html"
        },
        ".json": {
          "relative_path": "api/toc.json"
        }
      },
      "version": ""
    },
    {
      "type": "Toc",
      "source_relative_path": "toc.yml",
      "output": {
        ".html": {
          "relative_path": "toc.html"
        },
        ".json": {
          "relative_path": "toc.json"
        }
      },
      "version": ""
    }
  ],
  "groups": [
    {
      "xrefmap": "xrefmap.yml"
    }
  ]
}