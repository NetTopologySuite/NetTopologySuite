<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Namespace NetTopologySuite.Coverage | NetTopologySuite </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Namespace NetTopologySuite.Coverage | NetTopologySuite ">
    
    <meta name="description" content="Contains classes that operate on polygonal coverages. A polygonal coverage is a set of polygonal geometries which is non-overlapping and edge-matched (Polygon or MultiPolygon) A set of polygonal geometries is a valid coverage if:  Each geometry is valid. The interiors of all polygons are disjoint (they are not overlapping). This is the case if no polygon has a boundary which intersects the interior of another polygon. Where polygons are adjacent (i.e. their boundaries intersect), they are edge matched: the vertices (and thus line segments) of the common boundary match exactly.  A coverage may contain holes and disjoint regions. Coverage algorithms (such as CoverageUnion) generally require the input coverage to be valid to produce correct results. Coverages can be validated using { CoverageValidator}.">
      <link rel="shortcut icon" href="../favicon.ico">
      <link rel="stylesheet" href="../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../styles/docfx.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta property="docfx:navrel" content="../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="NetTopologySuite.Coverage">

  <h1 id="NetTopologySuite_Coverage" data-uid="NetTopologySuite.Coverage" class="text-break">Namespace NetTopologySuite.Coverage</h1>
  <div class="markdown level0 summary">
<p>Contains classes that operate on polygonal coverages.</p>
<p>A polygonal coverage is a set of polygonal geometries which is non-overlapping and edge-matched
(<a class="xref" href="NetTopologySuite.Geometries.Polygon.html">Polygon</a> or <a class="xref" href="NetTopologySuite.Geometries.MultiPolygon.html">MultiPolygon</a>)
A set of polygonal geometries is a valid coverage if:</p>
<ol>
<li>Each geometry is valid.</li>
<li>The interiors of all polygons are disjoint (they are not overlapping).
This is the case if no polygon has a boundary which intersects the interior of another polygon.</li>
<li>Where polygons are adjacent (i.e. their boundaries intersect),
they are <b>edge matched</b>: the vertices
(and thus line segments) of the common boundary match exactly.</li>
</ol>
<p>A coverage may contain holes and disjoint regions.</p>
<p>Coverage algorithms (such as <a class="xref" href="NetTopologySuite.Coverage.CoverageUnion.html">CoverageUnion</a>)
generally require the input coverage to be valid to produce correct results.
Coverages can be validated using {@link CoverageValidator}.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">
Classes
</h3>
      <h4><a class="xref" href="NetTopologySuite.Coverage.CoverageGapFinder.html">CoverageGapFinder</a></h4>
      <section><p>Finds gaps in a polygonal coverage.
Gaps are holes in the coverage which are narrower than a given width.</p>
<p></p>
The coverage should be valid according to {@link CoverageValidator}.
If this is not the case, some gaps may not be reported, or the invocation may fail.
<p></p>
This is a more accurate way of identifying gaps
than using {@link CoverageValidator#setGapWidth(double)}.
Gaps which separate the coverage into two disjoint regions are not detected.
Gores are not identified as gaps.&gt;
</section>
      <h4><a class="xref" href="NetTopologySuite.Coverage.CoveragePolygonValidator.html">CoveragePolygonValidator</a></h4>
      <section><p>Validates that a polygon forms a valid polygonal coverage
with the set of polygons adjacent to it.
If the polygon is coverage-valid an empty { @link LineString} is returned.
Otherwise, the result is a linear geometry containing
the polygon boundary linework causing the invalidity.</p>
<p></p>
A polygon is coverage-valid if:
<ol><li>The polygon interior does not intersect the interior of other polygons.</li><li>If the polygon boundary intersects another polygon boundary, the vertices
and line segments of the intersection match exactly.</li></ol>
<p></p>
The algorithm detects the following coverage errors:
<ol><li>the polygon is a duplicate of another one</li><li>a polygon boundary segment equals an adjacent segment (with same orientation).
This determines that the polygons overlap</li><li>a polygon boundary segment is collinear and overlaps an adjacent segment
but is not equal to it
</li><li>a polygon boundary segment touches an adjacent segment at a non-vertex point</li><li>a polygon boundary segment crosses into an adjacent polygon</li><li>a polygon boundary segment is in the interior of an adjacent polygon</li></ol>
<p></p>
<p>If any of these errors is present, the target polygon
does not form a valid coverage with the adjacent polygons.</p>
<p></p>
The validity rules do not preclude properly noded gaps between coverage polygons.
However, this class can detect narrow gaps,
by specifying a maximum gap width using {@link #setGapWidth(double)}.
Note that this will also identify narrow gaps separating disjoint coverage regions,
and narrow gores.
In some situations it may also produce false positives
(i.e.linework identified as part of a gap which is wider than the given width).
To fully identify gaps it maybe necessary to use <a class="xref" href="NetTopologySuite.Coverage.CoverageUnion.html">CoverageUnion</a> and analyze
the holes in the result to see if they are acceptable.
<p></p>
A polygon may be coverage-valid with respect to
a set of surrounding polygons, but the collection as a whole may not
form a clean coverage.For example, the target polygon boundary may be fully matched
by adjacent boundary segments, but the adjacent set contains polygons
which are not coverage - valid relative to other ones in the set.
A coverage is valid only if every polygon in the coverage is coverage - valid.
Use <a class="xref" href="NetTopologySuite.Coverage.CoverageValidator.html">CoverageValidator</a> to validate an entire set of polygons.
<p></p>
The adjacent set may contain polygons which do not intersect the target polygon.
These are effectively ignored during validation (but may decrease performance).
</section>
      <h4><a class="xref" href="NetTopologySuite.Coverage.CoverageSimplifier.html">CoverageSimplifier</a></h4>
      <section><p>Simplifies the boundaries of the polygons in a polygonal coverage
while preserving the original coverage topology.
An area-based simplification algorithm
(similar to Visvalingam-Whyatt simplification)
is used to provide high-quality results.
Also supports simplifying just the inner edges in a coverage,
which allows simplifying &quot;patches&quot; without affecting their boundary.</p>
<p></p>
The amount of simplification is determined by a tolerance value,
which is a non-negative quantity. It equates roughly to the maximum
distance by which a simplified line can change from the original.
(In fact, it is the square root of the area tolerance used
in the Visvalingam-Whyatt algorithm.)
<p></p>
The simplified result coverage has the following characteristics:
<ul><li>It has the same number of polygonal geometries as the input</li><li>If the input is a valid coverage, then so is the result</li><li>Node points (inner vertices shared by three or more polygons,
or boundary vertices shared by two or more) are not changed</li><li>Polygons maintain their line-adjacency (edges are never removed)</li><li>Rings are simplified to a minimum of 4 vertices, to better preserve their shape</li><li>Rings smaller than the area tolerance are removed where possible.
This applies to both holes and "islands" (multipolygon elements
which are disjoint or touch another polygon at a single vertex).
At least one polygon is retained for each input geometry
(the one with largest area).</li></ul>
<p></p>
This class supports simplification using different distance tolerances
for inner and outer edges of the coverage(including no simplfication
using a tolerance of 0.0).
This allows, for example, inner simplification, which simplifies
only edges of the coverage which are adjacent to two polygons.
This allows partial simplification of a coverage, since a simplified
subset of a coverage still matches the remainder of the coverage.
<p></p>
The class allows specifying a separate tolerance for each element of the input coverage.
<p></p>
The input coverage should be valid according to <a class="xref" href="NetTopologySuite.Coverage.CoverageValidator.html">CoverageValidator</a>.
Invalid coverages may still be simplified, but the result will likely still be invalid.
<p></p>
<b>NOTE:</b><br>Due to different implementations of the <code>PriorityQueue</code> classes used in JTS and NTS
the results of the <code>CoverageSimplifier</code>'s simplification methods are not guaranteed
to be the same. Nonetheless both results are valid.
</section>
      <h4><a class="xref" href="NetTopologySuite.Coverage.CoverageUnion.html">CoverageUnion</a></h4>
      <section><p>Unions a polygonal coverage in an efficient way.</p>
<p></p>
Valid polygonal coverage topology allows merging polygons in a very efficient way.
</section>
      <h4><a class="xref" href="NetTopologySuite.Coverage.CoverageValidator.html">CoverageValidator</a></h4>
      <section><p>Validates a polygonal coverage, and returns the locations of
invalid polygon boundary segments if found.</p>
<p></p>
A polygonal coverage is a set of polygons which may be edge-adjacent but do
not overlap.
Coverage algorithms(such as { @link CoverageUnion}
or simplification)
generally require the input coverage to be valid to produce correct results.
A polygonal coverage is valid if:
<ol><li>The interiors of all polygons do not intersect(are disjoint).
This is the case if no polygon has a boundary which intersects the interior of another polygon,
and no two polygons are identical.</li><li>If the boundaries of polygons intersect, the vertices
and line segments of the intersection match exactly.</li></ol>
<p></p>
A valid coverage may contain holes(regions of no coverage).
Sometimes it is desired to detect whether coverages contain
narrow gaps between polygons
(which can be a result of digitizing error or misaligned data).
This class can detect narrow gaps,
by specifying a maximum gap width using {@link #setGapWidth(double)}.
Note that this also identifies narrow gaps separating disjoint coverage regions,
and narrow gores.
In some situations it may also produce false positives
(linework identified as part of a gap which is actually wider).
See <a class="xref" href="NetTopologySuite.Coverage.CoverageGapFinder.html">CoverageGapFinder</a> for an alternate way to detect gaps which may be more accurate.
</section>


</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/NetTopologySuite/NetTopologySuite/blob/main/doc/overwrite/namespaces/NetTopologySuite.Coverage.md/#L2" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
