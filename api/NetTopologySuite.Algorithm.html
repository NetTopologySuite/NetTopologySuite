<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Namespace NetTopologySuite.Algorithm | NetTopologySuite </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Namespace NetTopologySuite.Algorithm | NetTopologySuite ">
    
    <meta name="description" content="Contains classes and interfaces implementing fundamental computational geometry algorithms. Robustness Geometrical algorithms involve a combination of combinatorial and numerical computation. As with all numerical computation using finite-precision numbers, the algorithms chosen are susceptible to problems of robustness. A robustness problem occurs when a numerical calculation produces an incorrect answer for some inputs due to round-off errors. Robustness problems are especially serious in geometric computation, since they can result in errors during topology building. There are many approaches to dealing with the problem of robustness in geometrical computation. Not surprisingly, most robust algorithms are substantially more complex and less performant than the non-robust versions. Fortunately, NTS is sensitive to robustness problems in only a few key functions (such as line intersection and the point-in-polygon test). There are efficient robust algorithms available for these functions, and these algorithms are implemented in NTS. Computational Performance Runtime performance is an important consideration for a production-quality implementation of geometric algorithms. The most computationally intensive algorithm used in NTS is intersection detection. NTS methods need to determine both all intersection between the line segments in a single Geometry (self-intersection) and all intersections between the line segments of two different Geometries. The obvious naive algorithm for intersection detection (comparing every segment with every other) has unacceptably slow performance. There is a large literature of faster algorithms for intersection detection. Unfortunately, many of them involve substantial code complexity. NTS tries to balance code simplicity with performance gains. It uses some simple techniques to produce substantial performance gains for common types of input data. Package Specification  Java Topology Suite Technical Specifications OpenGIS Simple Features Specification for SQL">
      <link rel="shortcut icon" href="../favicon.ico">
      <link rel="stylesheet" href="../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../styles/docfx.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta property="docfx:navrel" content="../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="NetTopologySuite.Algorithm">

  <h1 id="NetTopologySuite_Algorithm" data-uid="NetTopologySuite.Algorithm" class="text-break">Namespace NetTopologySuite.Algorithm</h1>
  <div class="markdown level0 summary">
<p>Contains classes and interfaces implementing fundamental computational geometry algorithms.</p>
<h2 id="robustness">Robustness</h2>
<p>Geometrical algorithms involve a combination of combinatorial and numerical computation. As with all numerical computation using finite-precision numbers, the algorithms chosen are susceptible to problems of robustness. A robustness problem occurs when a numerical calculation produces an incorrect answer for some inputs due to round-off errors. Robustness problems are especially serious in geometric computation, since they can result in errors during topology building.</p>
<p>There are many approaches to dealing with the problem of robustness in geometrical computation. Not surprisingly, most robust algorithms are substantially more complex and less performant than the non-robust versions. Fortunately, NTS is sensitive to robustness problems in only a few key functions (such as line intersection and the point-in-polygon test). There are efficient robust algorithms available for these functions, and these algorithms are implemented in NTS.</p>
<h2 id="computational-performance">Computational Performance</h2>
<p>Runtime performance is an important consideration for a production-quality implementation of geometric algorithms. The most computationally intensive algorithm used in NTS is intersection detection. NTS methods need to determine both all intersection between the line segments in a single Geometry (self-intersection) and all intersections between the line segments of two different Geometries.</p>
<p>The obvious naive algorithm for intersection detection (comparing every segment with every other) has unacceptably slow performance. There is a large literature of faster algorithms for intersection detection. Unfortunately, many of them involve substantial code complexity. NTS tries to balance code simplicity with performance gains. It uses some simple techniques to produce substantial performance gains for common types of input data.</p>
<h1 id="package-specification">Package Specification</h1>
<ul>
<li>Java Topology Suite Technical Specifications</li>
<li><a href="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features Specification for SQL</a></li>
</ul>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">
Classes
</h3>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.AngleUtility.html">AngleUtility</a></h4>
      <section><p>Utility functions for working with angles.
Unless otherwise noted, methods in this class express angles in radians.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.Area.html">Area</a></h4>
      <section><p>Functions for computing area.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.BoundaryNodeRules.html">BoundaryNodeRules</a></h4>
      <section><p>Provides access to static instances of common <a class="xref" href="NetTopologySuite.Algorithm.IBoundaryNodeRule.html">IBoundaryNodeRule</a>s.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.CGAlgorithms3D.html">CGAlgorithms3D</a></h4>
      <section><p>Basic computational geometry algorithms
for geometry and coordinates defined in 3-dimensional Cartesian space.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.CGAlgorithmsDD.html">CGAlgorithmsDD</a></h4>
      <section><p>Implements basic computational geometry algorithms using <a class="xref" href="NetTopologySuite.Mathematics.DD.html">DD</a> arithmetic.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.Centroid.html">Centroid</a></h4>
      <section><p>Computes the centroid of a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a> of any dimension.
For collections the centroid is computed for the collection of
non-empty elements of highest dimension.
The centroid of an empty geometry is <code>null</code></p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.ConvexHull.html">ConvexHull</a></h4>
      <section><p>Computes the convex hull of a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a>.
The convex hull is the smallest convex Geometry that contains all the
points in the input Geometry.</p>
<p></p>
Uses the Graham Scan algorithm.
<p></p>
Incorporates heuristics to optimize checking for degenerate results,
and to reduce the number of points processed for large inputs.
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.DistanceComputer.html">DistanceComputer</a></h4>
      <section><p>Functions to compute distance between basic geometric structures.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.ElevationModel.html">ElevationModel</a></h4>
      <section><p>A base elevation model class.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.ElevationModels.html">ElevationModels</a></h4>
      <section><p>Extension methods to work with <a class="xref" href="NetTopologySuite.Algorithm.ElevationModel.html">ElevationModel</a>s.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.HCoordinate.html">HCoordinate</a></h4>
      <section><p>Represents a homogeneous coordinate in a 2-D coordinate space.
In NTS <a class="xref" href="NetTopologySuite.Algorithm.HCoordinate.html">HCoordinate</a>s are used as a clean way
of computing intersections between line segments.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.InteriorPoint.html">InteriorPoint</a></h4>
      <section><p>Computes an interior point of a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a>.
An interior point is guaranteed to lie in the interior of the Geometry,
if it possible to calculate such a point exactly.
For collections the interior point is computed for the collection of
non-empty elements of highest dimension.
Otherwise, the point may lie on the boundary of the geometry.</p>
<p></p>
The interior point of an empty geometry is <code>POINT EMPTY</code>.
<h2>Algorithm</h2>
The point is chosen to be "close to the center" of the geometry.
The location depends on the dimension of the input:
<ul><li><span class="term">Dimension 2</span>the interior point is constructed in the middle of the longest interior segment
of a line bisecting the area.</li><li><span class="term">Dimension 1</span>the interior point is the interior or boundary vertex closest to the centroid.</li><li><span class="term">Dimension 0</span>the point is the point closest to the centroid.</li></ul>
<a class="xref" href="NetTopologySuite.Algorithm.Centroid.html">Centroid</a>
<a class="xref" href="NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle.html">MaximumInscribedCircle</a>
<a class="xref" href="NetTopologySuite.Algorithm.Construct.LargestEmptyCircle.html">LargestEmptyCircle</a>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.InteriorPointArea.html">InteriorPointArea</a></h4>
      <section><p>Computes a point in the interior of an areal geometry.
The point will lie in the geometry interior
in all except certain pathological cases.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.InteriorPointLine.html">InteriorPointLine</a></h4>
      <section><p>Computes a point in the interior of an linear point.
Algorithm:
Find an interior vertex which is closest to
the centroid of the linestring.
If there is no interior vertex, find the endpoint which is
closest to the centroid.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.InteriorPointPoint.html">InteriorPointPoint</a></h4>
      <section><p>Computes a point in the interior of an point point.
Algorithm:
Find a point which is closest to the centroid of the point.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.IntersectionComputer.html">IntersectionComputer</a></h4>
      <section><p>Functions to compute intersection points between lines and line segments.</p>
<p></p>
In general it is not possible to compute
the intersection point of two lines exactly, due to numerical roundoff.
This is particularly true when the lines are nearly parallel.
These routines uses numerical conditioning on the input values
to ensure that the computed value is very close to the correct value.
<p></p>
The Z-ordinate is ignored, and not populated.
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.Length.html">Length</a></h4>
      <section><p>Functions for computing length.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html">LineIntersector</a></h4>
      <section><p>A <code>LineIntersector</code> is an algorithm that can both test whether
two line segments intersect and compute the intersection point(s)
if they do.</p>
<p>
There are three possible outcomes when determining whether two line segments intersect:
<ul><li><a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html#NetTopologySuite_Algorithm_LineIntersector_NoIntersection">NoIntersection</a> - the segments do not intersect</li><li><a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html#NetTopologySuite_Algorithm_LineIntersector_PointIntersection">PointIntersection</a> - the segments intersect in a single point</li><li><a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html#NetTopologySuite_Algorithm_LineIntersector_CollinearIntersection">CollinearIntersection</a> - the segments are collinear and they intersect in a line segment</li></ul>

<p>
For segments which intersect in a single point, the point may be either an endpoint
or in the interior of each segment.
If the point lies in the interior of both segments,
this is termed a <i>proper intersection</i>.
The property <a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html#NetTopologySuite_Algorithm_LineIntersector_IsProper">IsProper</a> test for this situation.
</p><p>
The intersection point(s) may be computed in a precise or non-precise manner.
Computing an intersection point precisely involves rounding it
via a supplied <a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html#NetTopologySuite_Algorithm_LineIntersector_PrecisionModel">PrecisionModel</a>.
</p><p>
LineIntersectors do not perform an initial envelope intersection test
to determine if the segments are disjoint.
This is because this class is likely to be used in a context where
envelope overlap is already known to occur (or be likely).
</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.MinimumAreaRectangle.html">MinimumAreaRectangle</a></h4>
      <section><p>Computes the minimum-area rectangle enclosing a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a>.
Unlike the <a class="xref" href="NetTopologySuite.Geometries.Envelope.html">Envelope</a>, the rectangle may not be axis-parallel.</p>
<p></p>
The first step in the algorithm is computing the convex hull of the Geometry.
If the input Geometry is known to be convex, a hint can be supplied to
avoid this computation.
<p></p>
In degenerate cases the minimum enclosing geometry
may be a <a class="xref" href="NetTopologySuite.Geometries.LineString.html">LineString</a> or a <a class="xref" href="NetTopologySuite.Geometries.Point.html">Point</a>.
<p></p>
The minimum - area enclosing rectangle does not necessarily
have the minimum possible width.
Use {@link MinimumDiameter} to compute this.
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.MinimumBoundingCircle.html">MinimumBoundingCircle</a></h4>
      <section><p>Computes the <b>Minimum Bounding Circle</b> (MBC) for the points in a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a>.
The MBC is the smallest circle which <tt>cover</tt>s all the input points
(this is also sometimes known as the <b>Smallest Enclosing Circle</b>).
This is equivalent to computing the Maximum Diameter of the input point set.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.MinimumDiameter.html">MinimumDiameter</a></h4>
      <section><p>Computes the minimum diameter of a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a>.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.NotRepresentableException.html">NotRepresentableException</a></h4>
      <section></section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.Orientation.html">Orientation</a></h4>
      <section><p>Functions to compute the orientation of basic geometric structures
including point triplets(triangles) and rings.
Orientation is a fundamental property of planar geometries
(and more generally geometry on two-dimensional manifolds).</p>
<p></p>
Determining triangle orientation
is notoriously subject to numerical precision errors
in the case of collinear or nearly collinear points.
NTS uses extended-precision arithmetic to increase
the robustness of the computation.
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.PointLocation.html">PointLocation</a></h4>
      <section><p>Functions for locating points within basic geometric
structures such as lines and rings.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.PointLocator.html">PointLocator</a></h4>
      <section><p>Computes the topological relationship (<a class="xref" href="NetTopologySuite.Geometries.Location.html">Location</a>) of a single point to a Geometry.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.RayCrossingCounter.html">RayCrossingCounter</a></h4>
      <section><p>Counts the number of segments crossed by a horizontal ray extending to the right
from a given point, in an incremental fashion.</p>
<p>This can be used to determine whether a point lies in a <a class="xref" href="NetTopologySuite.Geometries.IPolygonal.html">IPolygonal</a> geometry.</p>
<p>The class determines the situation where the point lies exactly on a segment.</p>
<p>When being used for Point-In-Polygon determination, this case allows short-circuiting the evaluation.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.RectangleLineIntersector.html">RectangleLineIntersector</a></h4>
      <section><p>Computes whether a rectangle intersects line segments.</p>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.RobustDeterminant.html">RobustDeterminant</a></h4>
      <section><p>Implements an algorithm to compute the
sign of a 2x2 determinant for double precision values robustly.
It is a direct translation of code developed by Olivier Devillers.</p>
<p>The original code carries the following copyright notice:</p>
<hr>
<p>Author : Olivier Devillers
Olivier.Devillers@sophia.inria.fr
http:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html</p>
<p>Olivier Devillers has allowed the code to be distributed under
the LGPL (2012-02-16) saying &quot;It is ok for LGPL distribution.&quot;</p>
<hr>
<hr>
<p>Copyright (c) 1995  by  INRIA Prisme Project
BP 93 06902 Sophia Antipolis Cedex, France.
All rights reserved</p>
<hr>
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.RobustLineIntersector.html">RobustLineIntersector</a></h4>
      <section><p>A robust version of <a class="xref" href="NetTopologySuite.Algorithm.LineIntersector.html">LineIntersector</a>.</p>
</section>
    <h3 id="interfaces">
Interfaces
</h3>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.IBoundaryNodeRule.html">IBoundaryNodeRule</a></h4>
      <section><p>An interface for rules which determine whether node points
which are in boundaries of <a class="xref" href="NetTopologySuite.Geometries.ILineal.html">ILineal</a> geometry components
are in the boundary of the parent geometry collection.
The SFS specifies a single kind of boundary node rule,
the <a class="xref" href="NetTopologySuite.Algorithm.BoundaryNodeRules.html">BoundaryNodeRules.Mod2BoundaryNodeRule</a> rule.
However, other kinds of Boundary Node Rules are appropriate
in specific situations (for instance, linear network topology
usually follows the <a class="xref" href="NetTopologySuite.Algorithm.BoundaryNodeRules.html">BoundaryNodeRules.EndPointBoundaryNodeRule</a>.)
Some JTS operations
(such as <a class="xref" href="NetTopologySuite.Operation.Relate.RelateOp.html">RelateOp</a>, <a class="xref" href="NetTopologySuite.Operation.BoundaryOp.html">BoundaryOp</a> and <a class="xref" href="NetTopologySuite.Operation.Valid.IsSimpleOp.html">IsSimpleOp</a>)
allow the BoundaryNodeRule to be specified,
and respect the supplied rule when computing the results of the operation.</p>
<p></p>
An example use case for a non-SFS-standard Boundary Node Rule is
that of checking that a set of <a class="xref" href="NetTopologySuite.Geometries.LineString.html">LineString</a>s have
valid linear network topology, when turn-arounds are represented
as closed rings.  In this situation, the entry road to the
turn-around is only valid when it touches the turn-around ring
at the single (common) endpoint.  This is equivalent
to requiring the set of <tt>LineString</tt>s to be
<b>simple</b> under the <a class="xref" href="NetTopologySuite.Algorithm.BoundaryNodeRules.html">BoundaryNodeRules.EndPointBoundaryNodeRule</a>.
The SFS-standard <a class="xref" href="NetTopologySuite.Algorithm.BoundaryNodeRules.html">BoundaryNodeRules.Mod2BoundaryNodeRule</a> is not
sufficient to perform this test, since it
states that closed rings have <b>no</b> boundary points.
<p></p>
This interface and its subclasses follow the <tt>Strategy</tt> design pattern.
</section>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.IPointInAreaLocator.html">IPointInAreaLocator</a></h4>
      <section><p>An interface for classes which determine the <a class="xref" href="NetTopologySuite.Geometries.Location.html">Location</a> of points in a <a class="xref" href="NetTopologySuite.Geometries.Geometry.html">Geometry</a></p>
</section>
    <h3 id="enums">
Enums
</h3>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.OrientationIndex.html">OrientationIndex</a></h4>
      <section><p>Angle orientation</p>
</section>
    <h3 id="delegates">
Delegates
</h3>
      <h4><a class="xref" href="NetTopologySuite.Algorithm.ElevationModels.CoordinateSequenceToXYAndZ.html">ElevationModels.CoordinateSequenceToXYAndZ</a></h4>
      <section><p>Method signature to extract xy- and z-ordinate values from a coordinate sequence</p>
</section>


</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/NetTopologySuite/NetTopologySuite/blob/main/doc/overwrite/namespaces/NetTopologySuite.Algorithm.md/#L2" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
